This directory investigates whether it is possible to get a full proof of refinement with the seed trick

- [random.c](random.c) is the original C file. It declares a non deterministic function `char rand()` and defines
a main function that calls `rand`. The goal is to write the main function in cogent using the seed
trick to account for non-determinacy, keeping `rand` abstract. Then, we try to get a full refinement proof from
AutoCorres to the shallow embedding

- [random_seed.cogent](random_seed.cogent) is the cogent version using the seed trick. `main` is defined explicitely, while
`rand` is kept abstract (there called `rand_with_seed`)

- [random_seed.ac](random_seed.ac) defines the (dummy) abstract Seed type and implements the abstract function `rand_with_seed` using on the non deterministic 
C `rand()` function.



# Seed trick: questioning the refinement from AutoCorres to the shallow embedding

## The seed trick explained

Bilby uses some functions provided by the OS kernel like writing or reading to
the device, or allocating/freeing memory. 
As an example, consider the abstract function 
`newObj: SysState -> R (SysState, Obj take(..)) SysState` declared in 
`serial.cogent`. Here, `R` is the exception monad:
`type R a e = < Success a | Error e >`

This function allocates an object, but may fail (in case the memory is full).
When verifying Bilby, we do not expect to use and parse the true implementation of 
`newObj` provided by the kernel (by the way, I could not find where it is implemented.
Did someone managed to run the compiled C implementation?).
Instead we would rely on an axiomatized specification of it.
At the AutoCorres level, for example, we would provide `newObj` with a truly
non-deterministic semantic. As a consequence, any cogent function that calls
`newObj` would get a truly non-deterministic semantic at the AutoCorres layer. 
However, the shallow embedding generated by cogent is always deterministic, since Isabelle functions
are deterministic. Can we expect that a non-deterministic function refines a 
truly non-deterministic one? At first sight it seems impossible: if `f` can return
two different values for the same input and not `f'`, then clearly `f'` does not
refine `f`. 

This is where the seed trick come into play. For the sake of the argument, instead
of the complicated `newObj` abstract function above, let's consider the case
of a random function `char rand();` provided by the OS kernel.
Suppose we want to get a refinement proof from AutoCorres to the shallow embedding
of the boresome cogent function:
```
main : () -> U8
main = rand () + rand ()
```
where `rand : () -> U8` is left abstract. As argued above, this naive attempt is 
doomed from the beginning since the shallow embedding of `main `is deterministic 
while the AutoCorres embedding is not (since it relies on the truly non-deterministic
AutoCorres specification that we give for `rand`).
Instead of a shallow embedding of type `unit → U8`, we want a non-deterministic
embedding of type `unit → U8 set`. The seed trick consists thus in rewriting
the cogent function so that each function threads through a dummy seed, so that
the generated shallow embedding has type `main : Seed → (U8, Seed)`. 
Then, we can define the non deterministic specification `main_nd : unit → U8 set` 
that we want and that it refines the generated `main`, in the sense that
`∀ s. fst (main s) ∈ main_nd ()`. To this end, you first need to deal with 
the abstract function `rand : Seed → (U8, Seed)`. Obviously, the non-deterministic
specification would be `rand_nd ≡ UNIV :: U8 set`, and as a nice consequence,
we can prove that `rand_nd` refines `rand`, whithout even knowing what
`rand` and `Seed` are, meaning we can leave them as `typedecl Seed` and
`consts rand`!

This is the approach taken in Bilby. The seed type is there called `SysState`
(hence the complicated type of `newObj` above). Cogent functions thread such a
dummy seed all along. The verification first shows refinement between the generated
shallow embeddings and the non-deterministic specifications as explained above,
leaving `SysState` as `typedecl` and abstract functions as `consts`, and
then proves that the non-deterministic specification is correct.

## The seed trick considered harmful

What the bilby verification does not currently address is the refinement between
the AutoCorres layer and the generated shallow embedding. Indeed, Bilby verification
is prior to Louis' work, which was the first to tackle refinement in the presence
of abstract types and functions.

What I want to argue now is that with the seed trick, it is impossible 
to prove refinement. This is what the theory file `RandomSimpl` shows, but 
I'll try to explain the argument here.

Let's consider the `rand` example. With the seed trick, the cogent part is as follows:
```
type Seed
rand_seed : Seed -> (Seed, U8)

main : Seed -> (Seed, U8)
main seed = 
  let (seed, v1) = rand_seed seed in
  let (seed, v2)  = rand_seed seed in
  (seed, v1 + v2)
```
The C part goes as follows:
```
// As in bilby, the seed type is just a dummy type
typedef struct Seed {
  int dummy;
} Seed;

// this C function is provided by the kernel, we don't provide
// an implementation but rather the AutoCorres specification
// mentioned above
char rand ();

// We implement rand_seed
$ty:(Seed, U8) rand_seed(Seed * s) {
   // This tuple is syntactic sugar
   return (s, rand());
}
```

When parsing the generated C program with autocorres and provide the non-deterministic
semantics for `rand`, we get an accurate description of our program.
For example, we can prove that the autocorres embedding of `main` is indeed a truly non-deterministic function.
But, that is actually the issue! Indeed, the shallow embedding generated by
cogent is of type `Seed → (Seed, U8)` so it is still deterministic. Hence, 
there is no chance we can prove refinement from AutoCorres to the shallow embedding.

## A workaround

One workaround consists in not relying on the generated shallow embedding at 
all when abstract non deterministic functions are involved.
Instead, you need to write your the non-deterministic shallow embedding and directly
prove refinement between the value semantics and this layer (actually, the compiler
could be extended to automatically generate this).
Indeed, non-determinism is already supported up to the value semantics.
Note that in this solution, the seed trick is no longer needed.
