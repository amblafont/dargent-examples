--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

include <gum/common/allocpool.cogent>
include <gum/common/list.cogent>
include <gum/common/common.cogent>
include <gum/common/log.cogent>
include <gum/kernel/linux/errno.cogent>
include <gum/fs/linux/vfs.cogent>
include <gum/common/allocpool.cogent>
include <gum/common/buffer.cogent>
include <gum/common/rbt.cogent>
include <gum/common/array.cogent>
-----------------





-------------- ubi.cogent

type EbNum = U32

-- See linux/mtd/ubi.h
type UbiMode = U32

ubiReadOnly : UbiMode
ubiReadOnly = 1

ubiReadWrite : UbiMode
ubiReadWrite = 2

ubiExclusive : UbiMode
ubiExclusive = 3

type UbiVol
type ResUbi = RR (SysState, UbiVol) () ErrCode

type UbiNum = U32
type UbiId = U32
type UbiVolInfo
{-
    ubi_num : UbiNum,
    vol_id : UbiId,
    size : U32, -- nb erase-blocks
    usable_leb_size : U32,
    cdev : U32
    -- more unused fields
-}

wubi_vol_ubi_num: UbiVolInfo! -> UbiNum
wubi_vol_vol_id: UbiVolInfo! -> UbiId
wubi_vol_size: UbiVolInfo! -> U32 -- nb erase-blocks
wubi_vol_usable_leb_size: UbiVolInfo! -> U32
wubi_vol_cdev: UbiVolInfo! -> U32

newUbiVolInfo: SysState -> R (SysState, UbiVolInfo) SysState
freeUbiVolInfo:  (SysState, UbiVolInfo) -> SysState

type UbiDevInfo
wubi_dev_min_io_size: UbiDevInfo! -> U32
wubi_dev_max_write_size: UbiDevInfo! -> U32
{-
    min_io_size :U32,
    max_write_size : U32
-}

newUbiDevInfo: SysState -> R (SysState, UbiDevInfo) SysState
freeUbiDevInfo: (SysState, UbiDevInfo) -> SysState

type WubiOpenP = #{ex:SysState, name:CString!, mode:UbiMode}
wubi_open: WubiOpenP -> R (SysState, UbiVol) SysState
type WubiOpenVolumeP = #{ex:SysState, ubi_num:UbiNum, vol_id:UbiId, mode:UbiMode}
wubi_open_volume: WubiOpenVolumeP -> R (SysState, UbiVol) SysState
wubi_close: (SysState, UbiVol) -> SysState

wubi_get_vol_info: (UbiVol!, UbiVolInfo) -> UbiVolInfo
type WubiGetDevInfoR = R UbiDevInfo (ErrCode, UbiDevInfo)
wubi_get_dev_info: (UbiNum, UbiDevInfo) -> WubiGetDevInfoR

type WubiIsMappedP = #{ex:SysState, ubi_vol:UbiVol!, ebnum:EbNum}
type WubiIsMappedR = RR SysState Bool ErrCode
wubi_is_mapped: WubiIsMappedP -> WubiIsMappedR 
-- ubi_is_mapped(ex, eb_number)
-- Indicates whether an erase-block is mapped by UBI (has been written to).

type WubiLebReadP = #{ex:SysState, ubi_vol:UbiVol!, ebnum:EbNum, buf: Buffer, buf_offs:BufOffs, nb_bytes:U32}
type WubiLebReadR = RR (SysState, Buffer) () ErrCode
wubi_leb_read: WubiLebReadP -> WubiLebReadR 
-- ubi_leb_read(ex, eb_number, buf, buf_offset, size)
-- Reads @size bytes of erase-block @eb_number into buf, 
-- data is read from the erase-block starting at offset @buf_offs,
-- data is copied into buf starting at offset @buf_offset of buf.
-- @nb_bytes: number of bytes to read
-- Note that the buffer as long as the erase-block to be able to read
-- the end of an erase-block. This is because we use the same offset
-- in the buffer is the one in the erase-block.

type WubiLebWriteP = #{ex:SysState, ubi_vol:UbiVol, ebnum:EbNum, robuf: Buffer!, buf_offs:BufOffs, nb_bytes:U32}
wubi_leb_write: WubiLebWriteP -> ResUbi
-- ubi_leb_write(ex, eb_number, (buf, buf_offs), size)
-- Writes @size bytes to erase-block @eb_number
-- data is written to the erase-block starting at offset @buf_offs,
-- data is read from buf starting at offset @buf_offset of buf.
-- @size has to be a multiple of mount_st.super.io_size
-- @buf_offs + @size must be lesser or equal to mount_st.super.eb_size

type WubiLebChangeP = #{ex:SysState, ubi_vol:UbiVol, ebnum:EbNum, robuf: Buffer!, nb_bytes:U32}
wubi_leb_change : WubiLebChangeP -> ResUbi
-- ubi_leb_change(ex, ubi_vol, eb_number, buf, len)

type WubiLebEraseP = #{ex:SysState, ubi_vol:UbiVol, ebnum:EbNum}
wubi_leb_erase : WubiLebEraseP -> ResUbi
-- ubi_leb_erase(ex, eb_number)
-- Erase the erase-block @eb_number.

-----------------





-------------- serial.cogent

bilbyFsMagic : U32
bilbyFsMagic = 0x0b17b9f5

bilbyFsXinfoMask : U64
bilbyFsXinfoMask = 0x1fffffff

bilbyFsXinfoShift : U64
bilbyFsXinfoShift = 29


bilbyFsObjTypeInode : U8
bilbyFsObjTypeInode = 0

bilbyFsObjTypeData : U8
bilbyFsObjTypeData = 1

bilbyFsObjTypeDentarr : U8
bilbyFsObjTypeDentarr = 2

bilbyFsObjTypeDel : U8
bilbyFsObjTypeDel = 3

bilbyFsObjTypeSuper : U8
bilbyFsObjTypeSuper = 4

bilbyFsObjTypePad : U8
bilbyFsObjTypePad = 5

bilbyFsObjTypeSum : U8
bilbyFsObjTypeSum = 6

bilbyFsOidMaskDentarr : U64
bilbyFsOidMaskDentarr = upcast bilbyFsObjTypeDentarr << bilbyFsXinfoShift

bilbyFsOidMaskData : U64
bilbyFsOidMaskData = upcast bilbyFsObjTypeData << bilbyFsXinfoShift

bilbyFsOidMaskInode : U64
bilbyFsOidMaskInode = upcast bilbyFsObjTypeInode << bilbyFsXinfoShift

bilbyFsOidMaskDel : U64
bilbyFsOidMaskDel = upcast bilbyFsObjTypeDel << bilbyFsXinfoShift

bilbyFsOidMaskPad : U64
bilbyFsOidMaskPad = upcast bilbyFsObjTypePad << bilbyFsXinfoShift

bilbyFsOidMaskSum : U64
bilbyFsOidMaskSum = upcast bilbyFsObjTypeSum << bilbyFsXinfoShift

bilbyFsOidMaskAll : U64
bilbyFsOidMaskAll = 7 << bilbyFsXinfoShift

type ObjType = U8
type ObjTrans = U8
type ObjId = U64
type ObjIdDentarr = U64
type ObjIdData = U64
type ObjIdInode = U64

type ObjSuper = { nb_eb : U32
                , eb_size : U32
                , io_size : U32
                , nb_reserved_gc : U32
                , nb_reserved_del : U32
                , cur_eb : U32
                , cur_offs : U32
                , last_inum : U32
                , next_sqnum : U64
}
newObjSuper: SysState -> R (SysState, ObjSuper take(..)) SysState
freeObjSuper: (SysState, ObjSuper take (..)) -> SysState

mkObjSuper: (ObjSuper take(..), UbiVolInfo!, UbiDevInfo!) -> ObjSuper
mkObjSuper (sup, vol, dev) = sup {nb_eb=wubi_vol_size vol,
    eb_size=wubi_vol_usable_leb_size vol,
    io_size=wubi_dev_min_io_size dev, nb_reserved_gc=0, nb_reserved_del=0,
    cur_eb=0, cur_offs=0, last_inum=0, next_sqnum=0}

bilbyFsObjSuperSize : U32
bilbyFsObjSuperSize = 40

type ObjUnion = <TObjDentarr ObjDentarr
  | TObjInode ObjInode
  | TObjData ObjData
  | TObjDel ObjDel
  | TObjSuper ObjSuper
  | TObjSummary ObjSummary
  | TObjPad ()>

type Obj = {
       magic : U32,
       crc : U32,
       sqnum : U64,
       offs : U32, -- in-mem only field
       len : U32,
      -- , pad1 : U8
      -- , pad2 : U8
       trans : ObjTrans,
       otype : ObjType,
       ounion : ObjUnion
}

type ObjData = #{
  id : ObjId,
  odata : WordArray U8
}
type ObjDel = #{ id : ObjId } take ()
type ObjSummary = {
  nb_sum_entry : U32, -- nb_sum_entry must be <= wordarray_length sum.entries
                   -- the wordarray is ususally larger than what's get serialised.
                   -- Using an array for this would be too inefficient.
  entries : WordArray ObjSumEntry, -- only @nb_sum_entry element get serialised on medium
  -- At the very end of the summary is the offset of the summary itself.
  sum_offs : U32
}
type ObjInodeFlags = U32

type ObjInode = {id : ObjId
           , size : U64
           , atime_sec : U64
           , ctime_sec : U64
           , mtime_sec : U64
           , nlink : U32
           , uid : U32
           , gid : U32
           , mode : U32
           , flags : ObjInodeFlags
           -- , pad : U64
}
type ObjSumEntry = #{
  id : U64,
  sqnum : U64,
  len : U32,
  del_flags_and_offs : U32,
  count : U16 -- nb of object covered by the deletion object
}
type ObjDentarr = {
  id : ObjId,
  nb_dentry : U32,
  entries : Array ObjDentry
}
type ObjDentry = {
  ino : U32,
  dtype : U8,
  -- pad : U8,
  nlen : U16,
  name : WordArray U8
}

newObj: SysState -> R (SysState, Obj take(..)) SysState
freeObj: (SysState, Obj take(..)) -> SysState

{-# cinline deep_freeObjSuper #-}
deep_freeObjSuper: (SysState, ObjSuper) -> SysState
deep_freeObjSuper(ex, v) = freeObjSuper(ex, v)
-----------------






--------------- bilbyfs.cogent

is_set: (U32, U32) -> Bool
is_set(flags, mask) = (flags .&. mask) /= 0

type ObjAddr = #{ ebnum : U32, offs : U32, len : U32, sqnum : U64 } 
mkObjAddr: ObjAddr
mkObjAddr = #{ebnum=0,offs=0,len=0,sqnum=0}
type FsInode = { a: U32 }

type MountState = {
  eb_recovery: U32,
  eb_recovery_offs: U32,
  super : ObjSuper,
  obj_sup: Obj take (ounion),
  super_offs: U32,
  vol : UbiVolInfo,
  dev : UbiDevInfo,
  no_summary : Bool
}
newMountState: SysState -> R (SysState, MountState take (..)) SysState
freeMountState: (SysState, MountState take (..)) -> SysState

type DelNode = #{
  id : ObjId,
  oaddr: ObjAddr
}

type IndexState = #{ addrs : Rbt ObjId ObjAddr } 

type RbtIndexNode = RbtNode ObjId ObjAddr

type GimNode = #{ count : U16, sqnum : U64 } 
type RbtGimNode = RbtNode ObjId GimNode

idx_to_gim_node: RbtIndexNode -> RbtGimNode

type FsopState = { is_ro : Bool } 
newFsopState: SysState -> R (SysState, FsopState take (..)) SysState
freeFsopState: (SysState, FsopState take (..)) -> SysState


type EbAddr = #{ ebnum : U32, offs : U32 } 

-- Invariant on FsmState / OstoreState
-- If ostore_st.cur_eb /= word32Max
--  fsm_st.used_eb[ostore_st.cur_eb] = True
-- endif
type FsmState = { nb_free_eb : U32
                , used_eb : WordArray U8
                , dirty_space : WordArray U32
                , gim : Rbt ObjId GimNode } 
newFsmState: (SysState) -> R (SysState, FsmState take (..)) SysState
freeFsmState: (SysState, FsmState take (..)) -> SysState

-- Invariant on OstoreState:
--   All objects in the index that have ostore_st.cur_eb
--   as ebnum, must also have an offset within 0 and used.
--   Their ino must be within bilbyFsFirstIno and next_inum
--   Their sqnum must be within 0 and next_sqnum

--   All the flash pages from 0 to sync_offs must contain
--   the same data as in wbuf.

type AllocPools = #{idx: AllocPool RbtIndexNode, gim: AllocPool RbtGimNode}

type OstoreState = {
  next_inum : U32
, next_sqnum : U64
, rbuf : Buffer
, wbuf_eb : U32
, wbuf : Buffer
, used : U32
, sync_offs : U32
, opad : Obj
, pools: AllocPools
, oaddr : ObjAddr
, fsm_st : FsmState
, index_st : IndexState
, ubi_vol : UbiVol
, summary : ObjSummary
, sum_obj : Obj
}
newOstoreState: (SysState) -> R (SysState, OstoreState take (..)) SysState
freeOstoreState: (SysState, OstoreState take (..)) -> SysState

type FsState = { fsop_st : FsopState
               , mount_st : MountState
               , ostore_st : OstoreState } 
newFsState: (SysState) -> R (SysState, FsState take (..)) SysState
freeFsState: (SysState, FsState take (..)) -> SysState

ostoreWriteNone : U32
ostoreWriteNone = 0

ostoreWriteGC : U32
ostoreWriteGC = 1

ostoreWriteDel : U32
ostoreWriteDel = 2

-- This flags forces ostore_sync to fill up the current erase-block.
-- If summaries are enabled, it ensures that a summary is written at
-- the end of the erase-block too.
ostoreWriteNewEb : U32
ostoreWriteNewEb = 4

ostoreWriteAtomEb : U32
ostoreWriteAtomEb = 8

ostoreWriteForceSync : U32
ostoreWriteForceSync = 16

nilObjId : U64
nilObjId = word64Max

bilbyFsTransIn : ObjTrans
bilbyFsTransIn = 1

bilbyFsTransCommit : ObjTrans
bilbyFsTransCommit = 2

bilbyFsPadObjId : ObjId
bilbyFsPadObjId = nilObjId

bilbyFsPadByte : U8
bilbyFsPadByte = 66

bilbyFsMaxObjPerTrans : U32
bilbyFsMaxObjPerTrans = 2048

bilbyFsMaxNameLen : U32
bilbyFsMaxNameLen = 255

bilbyFsMaxInum : U32
bilbyFsMaxInum = word32Max

bilbyFsMaxNbDentarrEntries : U32
bilbyFsMaxNbDentarrEntries = 16

bilbyFsSuperEbNum : U32
bilbyFsSuperEbNum = 0

bilbyFsFirstLogEbNum : U32
bilbyFsFirstLogEbNum = 2

bilbyFsBlockSize : U32
bilbyFsBlockSize = 4096

bilbyFsBlockShift : U32
bilbyFsBlockShift = 12

bilbyFsITypeReg: U8
bilbyFsITypeReg = 0
bilbyFsITypeDir: U8
bilbyFsITypeDir = 1
bilbyFsITypeLnk: U8
bilbyFsITypeLnk = 2
bilbyFsITypeBlk: U8
bilbyFsITypeBlk = 3
bilbyFsITypeChr: U8
bilbyFsITypeChr = 4
bilbyFsITypeFifo: U8
bilbyFsITypeFifo = 5
bilbyFsITypeSock: U8
bilbyFsITypeSock = 6
bilbyFsITypeCnt: U8
bilbyFsITypeCnt = 7

bilbyFsDefaultNbReservedGc : U32
bilbyFsDefaultNbReservedGc = 3

bilbyFsDefaultNbReservedDel : U32
bilbyFsDefaultNbReservedDel = 3

bilbyFsRootIno : U32
bilbyFsRootIno = 24


print_field_u32: (String, U32) -> ()
#if DEBUG
print_field_u32 (f, v) =
  cogent_debug f ;
  cogent_debug " " ;
  cogent_debug_u32 v ;
  cogent_debug "\n"
#else
print_field_u32 (_, _) = ()
#endif

print_field_u64: (String, U64) -> ()
#if DEBUG
print_field_u64 (f, v) =
  cogent_debug f ;
  cogent_debug " " ;
  cogent_debug_u64 v ;
  cogent_debug "\n"
#else
print_field_u64 (_, _) = ()
#endif

print_obj_super: ObjSuper! -> ()
#if DEBUG
print_obj_super obj =
  cogent_debug "ObjSuper\n" ;
  print_field_u32 ("eb_size", obj.eb_size) ;
  print_field_u32 ("io_size", obj.io_size) ;
  print_field_u32 ("cur_eb", obj.cur_eb) ;
  print_field_u32 ("cur_offs", obj.cur_offs) ;
  print_field_u64 ("next_sqnum", obj.next_sqnum) ;
  print_field_u32 ("last_inum", obj.last_inum) ;
  print_field_u32 ("nb_reserved_gc", obj.nb_reserved_gc) ;
  print_field_u32 ("nb_reserved_del", obj.nb_reserved_del) ;
  cogent_debug "end\n"
#else
print_obj_super _ = ()
#endif

bilbyfs_error: String -> ()
bilbyfs_error_u32: U32 -> ()

-----------------





-------------- ostore.cogent

-- version abstraite
ostore_init: (SysState, MountState!, OstoreState take (..)) -> R (SysState, OstoreState take ubi_vol) (ErrCode, SysState, OstoreState take (..))

obj_init_default: (Obj take (..), U8) -> Obj take (ounion)
obj_init_default(obj, otype) = obj {magic=bilbyFsMagic,crc=0,sqnum=0,offs=0,len=0,trans=bilbyFsTransIn,otype}

-----------------





-------------- fsop.cogent

#include "../src/debug.cogent.h"

type FsState' = {
  fsop_st : FsopState,
  mount_st : MountState,
  ostore_st : OstoreState take (ubi_vol)
}

-- fsop_init opens the UBI device and sets up default values for
-- mount_st fields that are not specific to the hardware.
-- We will then double check that these value are consistent with
-- the ones stored in the super-block of BilbyFs.
-- The information stored in mount_st by fsop_init should be enough
-- to be able to detect if the device is already mounted by another
-- instance of BilbyFs.
type FsState'Taken = FsState' take (..)
type FsopInitP = #{ex:SysState, fs_st: FsState'Taken, name: CString!}
type FsopFs'P = #{ex:SysState, fs_st: FsState'}
type FsopFs'E = #{err:ErrCode, ex:SysState, fs_st: FsState'Taken}
fsop_init: FsopInitP -> R FsopFs'P FsopFs'E
fsop_init #{ex,fs_st,name} =
  newMountState ex
  | Error ex ->
    Error #{err=eNoMem, ex, fs_st}
  | Success (ex, mount_st) ->
    newFsopState ex
    | Error ex ->
      let ex = freeMountState(ex, mount_st)
      in Error #{err=eNoMem, ex, fs_st}
    | Success (ex, fsop_st) ->
      newOstoreState ex
      | Error ex ->
        let ex = freeMountState(ex, mount_st)
        and ex = freeFsopState(ex, fsop_st)
        in Error #{err=eNoMem, ex, fs_st}
      | Success (ex, ostore_st) ->
        newUbiVolInfo ex
        | Error ex ->
          let ex = freeMountState(ex, mount_st)
          and ex = freeFsopState(ex, fsop_st)
          and ex = freeOstoreState(ex, ostore_st)
          in Error #{err=eInval, ex, fs_st}
        | Success (ex, vol) ->
          newUbiDevInfo ex
          | Error ex ->
            let ex = freeMountState(ex, mount_st)
            and ex = freeFsopState(ex, fsop_st)
            and ex = freeOstoreState(ex, ostore_st)
            and ex = freeUbiVolInfo(ex, vol)
            in Error #{err=eInval, ex, fs_st}
          | Success (ex, dev) ->
            newObj ex
            | Error ex ->
              let ex = freeMountState(ex, mount_st)
              and ex = freeFsopState(ex, fsop_st)
              and ex = freeOstoreState(ex, ostore_st)
              and ex = freeUbiVolInfo(ex, vol)
              and ex = freeUbiDevInfo(ex, dev)
              in Error #{err=eInval, ex, fs_st}
            | Success (ex, obj_sup) ->
              wubi_open #{ex,name,mode=ubiReadOnly}
              | Error ex ->
                let ex = freeMountState(ex, mount_st)
                and ex = freeFsopState(ex, fsop_st)
                and ex = freeOstoreState(ex, ostore_st)
                and ex = freeUbiVolInfo(ex, vol)
                and ex = freeUbiDevInfo(ex, dev)
                and ex = freeObj(ex, obj_sup)
                in Error #{err=eInval, ex, fs_st}
              | Success (ex, ubivol) ->
                let vol = wubi_get_vol_info(ubivol, vol) !ubivol
                and ubi_num = wubi_vol_ubi_num vol !vol
                in wubi_get_dev_info(ubi_num, dev)
                | Error (err, dev) ->
                  let ex = freeMountState(ex, mount_st)
                  and ex = freeFsopState(ex, fsop_st)
                  and ex = freeOstoreState(ex, ostore_st)
                  and ex = freeUbiVolInfo(ex, vol)
                  and ex = freeUbiDevInfo(ex, dev)
                  and ex = freeObj(ex, obj_sup)
                  and ex = wubi_close (ex, ubivol)
                  in Error #{err=eInval, ex, fs_st}
                | Success dev ->
                  newObjSuper ex
                  | Error ex ->
                    let ex = freeMountState(ex, mount_st)
                    and ex = freeFsopState(ex, fsop_st)
                    and ex = freeOstoreState(ex, ostore_st)
                    and ex = freeUbiVolInfo(ex, vol)
                    and ex = freeUbiDevInfo(ex, dev)
                    and ex = freeObj(ex, obj_sup)
                    and ex = wubi_close (ex, ubivol)
                    in Error #{err=eNoMem, ex, fs_st}
                  | Success (ex, super) ->
                    let super = mkObjSuper(super, vol, dev) !vol !dev
                    and obj_sup = obj_init_default(obj_sup, bilbyFsObjTypeSuper)
                    and mount_st = mount_st {vol, dev, eb_recovery=0,
                      eb_recovery_offs=0, super,
                      obj_sup, super_offs = 0, no_summary = False}
                    and fsop_st = fsop_st {is_ro=True}
                    and ex = wubi_close (ex, ubivol)
                    in ostore_init(ex, mount_st, ostore_st) !mount_st
                    | Error (err, ex, ostore_st) ->
                      let mount_st {obj_sup,vol,dev,super} = mount_st
                      and ex = deep_freeObjSuper(ex, super)
                      and ex = freeObj(ex, obj_sup)
                      and ex = freeMountState(ex, mount_st)
                      and ex = freeFsopState(ex, fsop_st)
                      and ex = freeOstoreState(ex, ostore_st)
                      and ex = freeUbiVolInfo(ex, vol)
                      and ex = freeUbiDevInfo(ex, dev)
                      in Error #{err, ex, fs_st}
                    | Success (ex, ostore_st) ->
                      let fs_st = fs_st {mount_st, ostore_st, fsop_st}
                      in Success #{ex, fs_st}
