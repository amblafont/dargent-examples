(*
  This file contains the locale SumRandom which includes the locale generated by AutoCorres.
  
  This file also includes the proof that the SumRandom locale is a subset of the top level 
  correspondence locale.

  This file also contains the trivial abstractions .
*)

theory SumRandom_Abstractions
imports                  
  "../build_random_seed/Random_seed_AllRefine"
  CogentCRefinement.Value_Relation
begin

section "SumRandom Locale Definition"

text \<open>Trivial instantiation of locales with FFI abstract type definitions (no abstract types in this program)\<close>

locale SumRandom = random_seed 
begin

section \<open>Definitions for instantiating the update semantics locale (update_sem)\<close>
(*
locale update_sem =
  fixes abs_typing :: "('f \<Rightarrow> poly_type) \<Rightarrow> 'a \<Rightarrow> name \<Rightarrow> type list \<Rightarrow> sigil \<Rightarrow> 'l set \<Rightarrow> 'l set \<Rightarrow> ('f, 'a, 'l) store \<Rightarrow> bool"
  and   abs_repr   :: "'a \<Rightarrow> name \<times> repr list"

  assumes abs_typing_bang : "abs_typing \<Xi> av n \<tau>s s r w \<sigma> \<Longrightarrow> abs_typing \<Xi> av n (map bang \<tau>s) (bang_sigil s) (r \<union> w) {} \<sigma>"
  and     abs_typing_noalias : "abs_typing \<Xi> av n \<tau>s s r w \<sigma> \<Longrightarrow> r \<inter> w = {}"
  and     abs_typing_readonly : "sigil_perm s \<noteq> Some Writable \<Longrightarrow> abs_typing \<Xi> av n \<tau>s s r w \<sigma> \<Longrightarrow> w = {}"
  and     abs_typing_escape   : "sigil_perm s \<noteq> Some ReadOnly \<Longrightarrow> 0, [], {} \<turnstile>* \<tau>s :\<kappa> k \<Longrightarrow> E \<in> k
                                  \<Longrightarrow> abs_typing \<Xi> av n \<tau>s s r w \<sigma> \<Longrightarrow> r = {}"
  and     abs_typing_valid : "abs_typing \<Xi> av n \<tau>s s r w \<sigma> \<Longrightarrow> p \<in> r \<union> w \<Longrightarrow> \<sigma> p \<noteq> None"
  and     abs_typing_repr : "abs_typing \<Xi> av n \<tau>s s r w \<sigma> \<Longrightarrow> abs_repr av = (n, map type_repr \<tau>s)"
  and     abs_typing_frame: "frame \<sigma> u \<sigma>' u' \<Longrightarrow> abs_typing \<Xi> av n \<tau>s s r w \<sigma> \<Longrightarrow> r \<inter> u = {}
                              \<Longrightarrow> w \<inter> u = {} \<Longrightarrow> abs_typing \<Xi> av n \<tau>s s r w \<sigma>'"
*)

text \<open>"Value typing for abstract types in the Update semantics\<close>

definition 
  abs_typing_u :: 
  "(funtyp \<Rightarrow> poly_type) \<Rightarrow> abstyp \<Rightarrow> name \<Rightarrow> type list \<Rightarrow> sigil \<Rightarrow> 
    ptrtyp set \<Rightarrow> ptrtyp set \<Rightarrow> (funtyp, abstyp, ptrtyp) store \<Rightarrow> bool" 
where
  "abs_typing_u env a name \<tau>s sig r w \<sigma> = False"

text \<open>maps an abstract type to it type representation\<close>

definition 
  abs_repr :: "abstyp \<Rightarrow> name \<times> repr list" 
where
  "abs_repr a \<equiv> (''Unknown Abstract Type'', [])"

text \<open>update semantics locale assumption: abs_typing_bang \<close>

(* Update Semantics locale assumptions *)

lemma abs_typing_bang_u: 
  "abs_typing_u xi av n \<tau>s s r w \<sigma>\<Longrightarrow> 
   abs_typing_u xi av n (map bang \<tau>s) (bang_sigil s) (r \<union> w) {} \<sigma>"
  by (simp add: abs_typing_u_def)

lemma abs_typing_noalias: 
  "abs_typing_u xi av n \<tau>s s r w \<sigma> \<Longrightarrow> 
   r \<inter> w = {}"
  by (simp add: abs_typing_u_def)
  
lemma abs_typing_readonly: 
  "sigil_perm s \<noteq> Some Writable \<Longrightarrow> 
   abs_typing_u xi av n \<tau>s s r w \<sigma> \<Longrightarrow> w = {}"
  by (simp add: abs_typing_u_def)



lemma abs_typing_escape: 
  "\<lbrakk> sigil_perm s \<noteq> Some ReadOnly; 
     0, [], {} \<turnstile>* \<tau>s :\<kappa> k; E \<in> k; 
     abs_typing_u xi av n \<tau>s s r w \<sigma>\<rbrakk> \<Longrightarrow> 
   r = {}"
  by (simp add: abs_typing_u_def)


lemma abs_typing_valid: 
  "abs_typing_u env av n \<tau>s s r w \<sigma>\<Longrightarrow> p \<in> r \<union> w \<Longrightarrow> \<sigma> p \<noteq> None"
  by (simp add: abs_typing_u_def)
(*
lemma abs_typing_unique_repr:
  "\<lbrakk> abs_typing_u env av n \<tau>s s r w \<sigma>;
     abs_typing_u env av n' \<tau>s' s' r' w' \<sigma>\<rbrakk> \<Longrightarrow>
   type_repr (TCon n \<tau>s s) = type_repr (TCon n' \<tau>s' s')"
  by (simp add: abs_typing_u_def)
*)
lemma abs_typing_repr : 
  "abs_typing_u env av n \<tau>s s r w \<sigma> \<Longrightarrow> abs_repr av = (n, map type_repr \<tau>s)"
  by (simp add: abs_typing_u_def)

(*
  and     abs_typing_frame: "frame \<sigma> u \<sigma>' u' \<Longrightarrow> abs_typing \<Xi> av n \<tau>s s r w \<sigma> \<Longrightarrow> r \<inter> u = {}
                              \<Longrightarrow> w \<inter> u = {} \<Longrightarrow> abs_typing \<Xi> av n \<tau>s s r w \<sigma>'"
*)


text \<open>Value typing for abstract types in the Value semantics\<close>

definition 
  abs_typing_v :: "abstyp \<Rightarrow> name \<Rightarrow> type list \<Rightarrow> bool"
where
  "abs_typing_v a name \<tau>s \<equiv> False"


text \<open>Value relation for abstract types between the Update and Value semantics\<close>

definition 
  abs_upd_val ::
   "abstyp \<Rightarrow> abstyp \<Rightarrow> name \<Rightarrow> Cogent.type list \<Rightarrow> sigil \<Rightarrow> 
    ptrtyp set \<Rightarrow> ptrtyp set \<Rightarrow>  bool" (*FIX: (funtyp, abstyp, ptrtyp) store \<Rightarrow> *)
where
  "abs_upd_val au av name \<tau>s sig r w  \<equiv> False"

text \<open>The value typing and value relation satisfy Cogent's FFI constraints\<close>

(* Value Semantics locale assumption *)

lemma abs_typing_bang_v : 
  "abs_typing_v av n \<tau>s \<Longrightarrow> abs_typing_v av n (map bang \<tau>s)" 
  by (simp add: abs_typing_v_def)


(* Correspondance locale assumptions *)

lemma abs_upd_val_to_vval_typing: 
  "abs_upd_val u v n \<tau>s s l r \<Longrightarrow> abs_typing_v v n \<tau>s"
  by (simp add: abs_upd_val_def)

lemma abs_upd_val_to_uval_typing: 
  "abs_upd_val u v n \<tau>s s l r \<Longrightarrow> abs_typing_u u n \<tau>s s l r"
  by (simp add: abs_upd_val_def)

lemma abs_upd_val_bang : 
  "abs_upd_val au av n \<tau>s s r w \<Longrightarrow> 
    abs_upd_val au av n (map bang \<tau>s) (bang_sigil s) (r \<union> w) {}"
  by (simp add: abs_upd_val_def)

end

section \<open>Sublocale Proof\<close>

text 
\<open>The value typing and value relation satisfy Cogent's FFI constraints\<close>

sublocale 
  SumRandom \<subseteq>  
   Random_seed_cogent_shallow _ 
       abs_repr 
       abs_typing_v 
       abs_typing_u 
       abs_upd_val
  apply  (unfold_locales)
            apply (simp add: abs_typing_bang_v) 
           apply (simp add: abs_typing_bang_u) 
          apply (simp add: abs_typing_noalias) 
         apply (simp add: abs_typing_readonly) 
        apply (simp add: abs_typing_escape) 
       apply (simp add: abs_typing_valid) (*FIX sigma in FFI*)
      apply (rule abs_typing_unique_repr, assumption, assumption)
     apply (simp add: abs_typing_repr) 
    apply (simp add: abs_upd_val_to_vval_typing)
   apply (simp add: abs_upd_val_to_uval_typing)
  apply (simp add: abs_upd_val_bang)
  done


end