
Dargent is a language improvement to Cogent that allows users to
specify how data-structures should be laid out in memory. This
feature is intended to improve inter-operation between Cogent and
C. Code-gen has been implemented for this feature. My long-term goal
is to extend the verification framework with this feature.

# Brief summary of Dargent

A record type can be associated a custom layout describing how the data 
should be mapped into memory.
When a record has been specified a custom layout, it is compiled to a record
with a single field consisting of an array of bytes (in the following discussion, 
I ignore this intermediary layer).

Custom getters and setters are generated along by the compiler (in C) for each field 
of the original cogent record, respecting the layout specification. 
They are used to compile the cogent Member/Take/Put operations.

A custom getter for a field of (cogent) type `T` takes the array 
of bytes as input and outputs a value of type `⟦T⟧`, where
 `⟦T⟧` denotes the C type to which `T` is compiled.

 
## Packing/Unpacking

Importantly, `⟦T⟧`, the return type of the custom getter,
does not depend on the layout specification:
it is the C type to which `T` would be compiled to
if all layout specifications were removed.
It means that a kind of packing/unpacking is systematically
involved in custom getters/setters. 
 

## Casts and AutoCorres
 
Custom getters involve casts from bytes to 
pointers (in the case the accessed field is a cogent boxed record, which 
corresponds to a pointer to a structure in C). AutoCorres is fine with it: 
I have been able to carry out the verification proof for such an example.

Similarily, custom setters involve casts from pointers to bytes.



# What I did

I am working on the Isabelle/ML part of cogent.
I have adapted the update/value semantics and their proof of correspondence to
the presence of custom layouts.
I have started tackling the correspondence proof between the generated C code
and the cogent code in the presence of custom layouts. 

More precisely,

- I have written a ML function which devises a direct definition of custom 
getters/setters, based on their monadic version generated by AutoCorres from
the C code. They are *direct* in the sense that they should correspond to the
isabelle code that would be generated if custom getters
and setters were compiled to Isabelle rather than C.

- I have written a ML function generating the statements of various lemmas
about custom getters and setters. I call them **get/set lemmas** in the 
following. The main remaining task consists in automating their proof.

- I have adapted the proof tactics for the generated Take/Put/Member lemmas:
they use the previously proven get/set lemmas when necessary. 

- I have explored the possibility of [compiling dargent to cogent with arrays](dargent-cast-ffi.md).
My (current) opinion is that it is not worth it, as it does not ease the difficult 
get/set lemmas.

## Get/Set lemmas

There are four type of get/set lemmas that must be proven, that I schematically
summarize here:
1. `val_rel x v ⇒ val_rel x (get_a (set_a p v))` (I explain this statement 
below more carefully)
2. `get_a ∘ set_b = get_a`
3. `C_get = direct_get`
4. `C_set = direct_set`

Here, `direct_get/set` refers to the direct definition of getters I mentionned
before, while `C_get/set` refers to the monadic definition generated by 
AutoCorres from the C code.

The first two statements involve the direct definitions.

The first statement weakens the more intuitive `get_a ∘ set_a = id`,
which is false in case the field is a variant. Indeed (technical discussion
follows), variants are compiled to structures packing all the fields for each 
constructor, with an additionnal tag field. Thus, at each stage, only a subset
of these fields is relevant, depending on the tag field. The custom getter must
return such a record, from a given byte array. Suppose it has inferred the tag
from the byte array, following the specified custom layout. The layout describes
how the relevant fields are retrieved from the byte array, but the getter must
provide values for the irrelevant fields as well. What else can it do but
provide arbitrary values for them? But then, the custom getter `get_a` is not surjective, so
there is no hope that `get_a ∘ set_a = id`.

# Plans

## Cogent-related


1. The big remaining task regarding the dargent formalization is the proof automation 
of the get/set lemmas. I am not sure how to address this. Hopefully Vincent is
getting involved as well.

<!-- I am still at the stage of looking at small examples. I think that the proof -->
<!-- automation tactic should be guided by the custom layout, as these custom -->
<!-- getters/setters can be arbitrarily complex with nested records. -->

2. I plan to adapt the verification framework to the array extension, 
beginning with its simplest version: fixed-sized arrays with fixed index 
accessing. In this version, they are similar to records (any cogent program with
such arrays can be compiled to a cogent program without arrays, by compiling 
arrays to records with the same number of fields as the size of this array),
so I don't expect any serious difficulty.

From a strategic viewpoint, I don't know which task is more important.
As far as I understand, having both arrays and dargent formalized would open the
door to interesting and useful examples.


## Side projects (non cogent-related)

I am working with my phd cosupervisor Tom Hirschowitz on some side projects:

- a rewriting of our conference paper [A cellular Howe theorem](https://amblafont.github.io/articles/lics20.pdf) 
which I (shamefully) didn't really understand at the time we 
(I, my co-supervisor, and his former intern Peio Borthelle) published it.
This work is a categorical rephrasing of the Howe method for proving that
bismilarity of, say, cbn lambda-calculus, is a congruence. The goal is to
produce a journal paper.

- a definition of an alternative operad of weak omega-categories, as a variant
of Leinster's operad (with Tom and Andre Hirschowitz).




