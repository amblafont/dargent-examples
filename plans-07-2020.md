
Dargent is a language improvement to Cogent that allows users to
specify how data-structures should be laid out in memory. This
feature is intended to improve inter-operation between Cogent and
C. Code-gen has been implemented for this feature. My long-term goal
is to extend the verification framework with this feature.

# Brief explanation of Dargent

A record type can be associated a custom layout describing how the data 
should be mapped into memory.
When a record has been specified a custom layout, it is compiled to a record
with a single field consisting of an array of bytes (in the following discussion, 
I ignore this intermediary layer).

Custom getters and setters are generated along in the C field for each field 
of the original cogent record, respecting the layout specification. 
They are used to compile the cogent Member/Take/Put operations.

A custom getter for a field of (cogent) type `T` takes the array 
of bytes as input and outputs a value of type `⟦T⟧`, where
 `⟦T⟧` denotes the C type to which `T` is compiled.

 
## Packing/Unpacking

Importantly, `⟦T⟧` does not depend on the layout specification:
it is the C type to which `T` would be compiled to
if all layout specifications were removed.
It means that a kind of packing/unpacking is systematically
involved in custom getters/setters. 
 

## Casts and AutoCorres
 
Custom getters involve casts from bytes to 
pointers (in the case the accessed field is a cogent boxed record, which 
corresponds to a pointer to a structure in C). AutoCorres is fine with it: 
I have been able to carry out the verification proof for such an example.

Similarily, custom setters invove casts from pointers to bytes.



# What I did

I am working on the Isabelle/ML part of cogent.
I have adapted the update/value semantics and their proof of correspondence to
the presence of custom layouts.
I have started tackling the correspondence proof between the generated C code
and the cogent code in the presence of custom layouts. 

More precisely,

- I have written a ML function which devises a direct definition of custom 
getters/setters, based on their monadic version generated by AutoCorres from
the C code. They are *direct* in the sense that they should correspond to the
isabelle code that would be generated if cogent was compiling custom getters
and setters to Isabelle rather than C.

- I have written a ML function generating the statements of various lemmas
about custom getters and setters. I call them **get/set lemmas** in the 
following. The main remaining task consists in automating their proof.

- I have adapted the proof tactics for the generated Take/Put/Member lemmas:
they use the previously proven get/set lemmas when necessary. 


## Get/Set lemmas

There are four type of get/set lemmas that must be proven, that I schematically
summarize here:
1. `val_rel x v ⇒ val_rel (get_a (set_a p v))` (I explain this statement 
below more carefully)
2. `get_a ∘ set_b = get_a`
3. `C_get = direct_get`
4. `C_set = direct_set`

Here, `direct_get/set` refers to the direct definition of getters I mentionned
before, while `C_get/set` refers to the monadic definition generated by 
AutoCorres from the C code.

The first two statements involve the direct definitions.

The first statement weakens the more intuitive `get_a ∘ set_a = id`,
which is false in case the field is a variant. Indeed (technical discussion
follows), variants are compiled to structures packing all the fields for each 
constructor, with an additionnal tag field. Thus, at each stage, only a subset
of these fields are relevant, depending on the tag field. The custom getter must
return such a record, from a given byte array. Suppose it has inferred the tag
from the byte array, following the specified custom layout. The layout describes
how the relevant fields are retrieved from the byte array, but the getter must
provide values for the irrelevant fields as well. What else can it do but
provide an arbitrary value for them? But then, `get_a` is not surjective, so
there is no hope that `get_a ∘ set_a = id`.

# Plans

- I have suggested compiling dargent to cogent with arrays. After some discussion
with Christine, Vincent, and Zilin, it seems not as easy as it first looks, 
because it requires back and forth casts between int and boxed records (this
happens in the case mentionned above about casts and AutoCorres).
I would like to think a bit more about this possibility, following Zilin's
suggestion about considering theses casts as FFI rather than extending the cogent
language.

- I plan to adapt the verification framework to the array extension, 
beginning with its simplest version: fixed-sized arrays with fixed index 
accessing. In this version, they are similar to records (any cogent program with
such arrays can be compiled to a cogent program without arrays, by compiling 
arrays to records with the same number of fields as the size of this array),
so I don't expect any serious diffulty.

- The big remaining task regarding dargent formalization is the proof automation 
of the get/set lemmas. 
My main concern is about the correspondence between C getters/setters
and their direct definitions. In some way, this is similar to 
the correspondence between C and cogent program, whose proof automation tactic
is quite complex.
I am still at the stage of looking at small examples. I think that the proof
automation tactic should be guided by the custom layout, as these custom
getters/setters can be arbitrarily complex with nested records.

# Conclusion

I am not very motivated to work alone on the big remaining task of working out
a proof automation tactic for the get/set lemmas (I expect this will take some 
monthes). Hopefully, I currently get some help from Vincent.

Also, when I was young, I was told by some guru to *publish or perish*, so
I hope these work on formalization will eventually lead to a publication. 
I am still working with Tom and Andre Hirschowitz on some side projects:

- a rewriting of our paper `A cellular Howe theorem` 
which I (shamefully) didn't really understand at the time we published it.
This is a categorical rephrasing of the Howe method proving that
bismilarity of, say, cbn lambda-calculus, is a congruence.

- a definition of an alternative operad of weak omega-categories, as a variant
of Leinster's operad.




