(*
This file is generated by Cogent

*)

theory Variant_dargentisa_CorresSetup_Edited
imports "CogentCRefinement.Deep_Embedding_Auto"
"CogentCRefinement.Cogent_Corres"
"CogentCRefinement.Tidy"
"CogentCRefinement.Heap_Relation_Generation"
"CogentCRefinement.Type_Relation_Generation"
"CogentCRefinement.Dargent_Custom_Get_Set"
"build_variant/Variant_dargentisa_ACInstall"
"build_variant/Variant_dargentisa_TypeProof"
"Lib.Apply_Trace_Cmd"
"../Complements"
begin

(* C type and value relations *)

instantiation unit_t_C :: cogent_C_val
begin
  definition type_rel_unit_t_C_def: "\<And> r. type_rel r (_ :: unit_t_C itself) \<equiv> r = RUnit"
  definition val_rel_unit_t_C_def: "\<And> uv. val_rel uv (_ :: unit_t_C) \<equiv> uv = UUnit"
  instance ..
end

instantiation bool_t_C :: cogent_C_val
begin
definition type_rel_bool_t_C_def: "\<And> typ. type_rel typ (_ :: bool_t_C itself) \<equiv> (typ = RPrim Bool)"
definition val_rel_bool_t_C_def:
   "\<And> uv x. val_rel uv (x :: bool_t_C) \<equiv> (boolean_C x = 0 \<or> boolean_C x = 1) \<and>
     uv = UPrim (LBool (boolean_C x \<noteq> 0))"
instance ..
end
context update_sem_init begin
lemmas corres_if = corres_if_base[where bool_val' = boolean_C,
                     OF _ _ val_rel_bool_t_C_def[THEN meta_eq_to_obj_eq, THEN iffD1]]
end


(* C heap type class *)
class cogent_C_heap = cogent_C_val +
  fixes is_valid    :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> bool"
  fixes heap        :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> 'a"

(*
Non-generated
*)




(* 
This ML function generate custom getters/setters in Isabelle from
the C custom getters/setters.

More precisely, the involved steps are:
1. get the names of custom C getters/setters from the table file
2. prove a simplified definition of them by unfolding the auxiliary 
   called C functions and using Tidy lemmas (thus produces Cgetter_def' 
   lemmas in the context). 
3. infer an isabelle definition of custom getter/setters by inspecting
   these simplified definition (and performing further simplification, such
   as removing all guards)

The simplified definitions are thought to be used later when proving that
the C and isabelle custom getters/setters match.

 *)


setup \<open>generate_isa_getset_records_for_file "variant_dargentisa.c" @{locale variant_dargentisa} \<close>


context variant_dargentisa begin

(* This prints the get/set lemmas that should be proven *)
ML \<open> val lems = mk_getset_lems "variant_dargentisa.c" @{context} \<close>
ML \<open>lems  |> map (string_of_getset_lem @{context})|> map tracing\<close>

(* This proves the get/set lemmas (currently by cheating) *)
(*
local_setup \<open>local_setup_getset_lemmas "variant_dargentisa.c"\<close>
*)
end

context variant_dargentisa begin



(* Example: 
 1 original C getter definition, 
 2 simplified unfolded definition
 3 isabelle C getter definition
*)
thm d3_get_a'_def d3_get_a'_def' deref_d3_get_a_def


end
(* the value/type relation were adapted to custom layouts *)
local_setup \<open> local_setup_val_rel_type_rel_put_them_in_buckets "variant_dargentisa.c" \<close>
thm val_rel_t1_C_def

(* 
Now are the various lemmas regarding custom getter/setters. We call them get/set lemmas

It is easy to automate the generation of the statements. The proof automation is, I think, the
remaining hard part (because we never know if we have addressed all the cases). 




https://github.com/amblafont/AutoCorres
* Different kind of lemmas

There are 4 different types of lemmas. I write the naive version below

1. `get o set = id`
2. `get_a o set_b = get_a`
3. `C_get = isabelle_get`
4. `C_set = isabelle_set`

(r : Simple)
get_b (set_b r (B u)) <> B u

B u = { tag = B, A_field = ?, B_field = u, .. }

get_b (r' : bytes[n]) = { tag = B, A_field = ?, B_field = . ,  }

r' = [ . . . . . ]
        [  A  ]
      [ B  ]
 
The first is too naive because it does not hold for variants: if a field is a variant,
then the associated getter erases the irrelevant fields. Thus equality is too strong,
but we can replace them with value relation preservation:

1. `val_rel x new_val \<Longrightarrow> val_rel x (get (set t new_val))`




* Where to generate these lemmas

I have written a function similar to mk_lems which generate get/set lemmas.

The reason I did not extend mk_lems is that the lemmas that mk_lems automatically proves about records
require the get/set lemmas to be proven first. But then, these lemmas are proven in an unspecified
order.  I did not dare breaking the "invariant" that lemmas generated by mk_lems can be proven in 
any order.

 *)

context variant_dargentisa begin

(* This prints the get/set lemmas that should be proven *)
ML \<open> val lems = mk_getset_lems "variant_dargentisa.c" @{context} \<close>
ML \<open>lems  |> map (string_of_getset_lem @{context})|> map tracing\<close>

(* This proves the get/set lemmas (currently by cheating) *)
(*
local_setup \<open>local_setup_getset_lemmas "variant_dargentisa.c"\<close>
*)


(* Here we try to prove the get/set lemmas manually.
This is the hard part to automate.
*)


lemma get_set_a' : 
(* The value relation is only there to ensure that the tag
is the right one *)
  "val_rel x v \<Longrightarrow> deref_d3_get_a (deref_d27_set_a b v) = v"
  apply(simp add:deref_d3_get_a_def deref_d27_set_a_def)
  apply(cases v)
  apply simp
  apply(rule conjI)
   apply (simp add:ValRelSimp)
   apply blast   
  by (word_bitwise)

lemma get_set_a [GetSetSimp] : 
(* The value relation is only there to ensure that the tag
is the right one *)
  "val_rel x v \<Longrightarrow> val_rel x (deref_d3_get_a (deref_d27_set_a b v))"
  apply(simp add:get_set_a')
  done



lemma index_update_eq:
  fixes f :: "'a[('b :: finite)]"
  assumes "k < CARD('b)"
  shows
  "(Arrays.update f n x.[k]) = (if n = k then x else f.[k])"
  using assms
  by simp

lemma tags_distinct':
  "TAG_ENUM_A \<noteq> TAG_ENUM_B"
  "TAG_ENUM_A \<noteq> TAG_ENUM_C"
  "TAG_ENUM_A \<noteq> TAG_ENUM_D"
  "TAG_ENUM_A \<noteq> TAG_ENUM_E"
  "TAG_ENUM_B \<noteq> TAG_ENUM_C"
  "TAG_ENUM_B \<noteq> TAG_ENUM_D"
  "TAG_ENUM_B \<noteq> TAG_ENUM_E"
  "TAG_ENUM_C \<noteq> TAG_ENUM_D"
  "TAG_ENUM_C \<noteq> TAG_ENUM_E"
  "TAG_ENUM_D \<noteq> TAG_ENUM_E"
  by (simp add: TAG_ENUM_A_def TAG_ENUM_B_def TAG_ENUM_C_def TAG_ENUM_D_def TAG_ENUM_E_def)+

lemmas tags_distinct = tags_distinct' tags_distinct'[symmetric]

lemma neg_disj_pos_conj_iff:
  "\<not> A \<and> (A \<or> B) \<longleftrightarrow> \<not> A \<and> B"
  by blast

lemma pos_disj_neg_conj_iff:
  "A \<or> (\<not>A \<and> B) \<longleftrightarrow> A \<or> B"
  by blast

lemma pos_disj_neg_conj_iff2:
  "A \<or> (B \<and> \<not>A) \<longleftrightarrow> A \<or> B"
  by blast

lemma posA_B_negA_iff:
  "A \<or> B \<or> \<not> A \<longleftrightarrow> True"
  by blast


lemma xANDyANDx_eq: "x && y && x = y && x"
  by (metis AND_twice word_bw_comms(1))

lemma ucast_and_distrib:
  "UCAST(('a::len) \<rightarrow> ('b::len)) (a && b) = UCAST('a \<rightarrow> 'b) a && UCAST('a \<rightarrow> 'b) b"
  unfolding ucast_def Word.bitAND_word.abs_eq uint_and
  by simp

lemma ucast_down_shiftr_distrib:
  "LENGTH('b) \<le> LENGTH('a) \<Longrightarrow> UCAST(('a::len) \<rightarrow> ('b::len)) (a << n) = UCAST('a \<rightarrow> 'b) a << n"
  apply (simp add: ucast_def uint_shiftl word_size shiftl_int_def)
  apply (simp add: wi_bintr wi_hom_syms)
  apply (simp add: shiftl_t2n word_of_int_2p)
  done

lemma ucast_up_shiftr_distrib:
  "LENGTH('b) \<ge> LENGTH('a) \<Longrightarrow> UCAST(('a::len) \<rightarrow> ('b::len)) (a << n) = (UCAST('a \<rightarrow> 'b) a << n) && mask LENGTH('a)"
  apply (simp add: ucast_def uint_shiftl word_size shiftl_int_def)
  apply (simp add: and_mask_wi[symmetric])
  apply (simp add: wi_hom_syms)
  apply (simp add: shiftl_t2n word_of_int_2p)
  apply (simp add: semiring_normalization_rules(7))
  done


lemma max_and_word_simps:
  "\<And>a::8 word. 0xFF && a = a"
  "\<And>a::16 word. 0xFFFF && a = a"
  "\<And>a::32 word. 0xFFFFFFFF && a = a"
  "\<And>a::64 word. 0xFFFFFFFFFFFFFFFF && a = a"
  by (simp add: word_and_max_simps word_bw_comms)+

ML\<open>
(* This tactic was created using the "throw things in and see if it works" strategy.
 * Eventually, we should write something more principled. ~ v.j. / 2020-07-15
 *)
fun solve_dargent_bitwise_tac ctxt i =
  let
  ; val reduce_variant1 (* only *) =  @{thms if_False if_True refl index_update_eq card_bit0 card_bit1}
  ; val reduce_variant2 = @{thms tags_distinct disj_imp[symmetric] Inductive.imp_conj_iff
                                 neg_disj_pos_conj_iff pos_disj_neg_conj_iff}
  ; val word_distrib_simpset =
    @{thms word_bool_alg.conj_disj_distrib word_bool_alg.conj_disj_distrib2
           shiftr_over_or_dist shiftr_over_and_dist
           shiftl_over_or_dist shiftl_over_and_dist
           word_bool_alg.conj.assoc
           word_bool_alg.disj.assoc
           ucast_and_distrib ucast_or_distrib ucast_ucast_mask}
  ; val word_simps2 =
    @{thms xANDyANDx_eq and_mask2 word_size ucast_or_distrib mask_def ucast_id word_and_max_simps
           max_and_word_simps}
  ; val word_join_simps =
    @{thms word_bool_alg.conj_disj_distrib[symmetric] word_and_max_simps max_and_word_simps}
  ; val word_left_right_shift_simps =
    @{thms and_mask2 and_not_mask[symmetric] mask_def
           word_bool_alg.conj.assoc word_bool_alg.disj.assoc}
  ; val cleanup_simps =
    @{thms pos_disj_neg_conj_iff pos_disj_neg_conj_iff2 posA_B_negA_iff}
   in ((simp_tac ((clear_simpset ctxt) addsimps reduce_variant1)
        THEN' simp_tac ((clear_simpset ctxt) addsimps reduce_variant2)
        THEN' (fn i => REPEAT_DETERM (DETERM (CHANGED (
          (simp_tac ((clear_simpset ctxt) addsimps word_distrib_simpset)
          THEN' simp_tac (ctxt addsimps word_simps2)
          ) i
        ))))
        THEN' (fn i => (TRY (
          (simp_tac (ctxt addsimps word_left_right_shift_simps)
          THEN' simp_tac (ctxt addsimps word_join_simps)
          THEN' (fn i => TRY (simp_tac (ctxt addsimps cleanup_simps) i))) i
      )))) i)
  end;
fun getput_variant_tac ctxt =
  let val tags_cleanup =
    @{thms tags_distinct if_False if_True refl disj_imp[symmetric] neg_disj_pos_conj_iff}
   in TRYALL (fn i => CHANGED (
        (simp_tac (ctxt addsimps tags_cleanup)
        THEN' solve_dargent_bitwise_tac ctxt) i))
  end;
\<close>


lemma get_set_b[GetSetSimp]: "val_rel x v \<Longrightarrow> val_rel x (deref_d9_get_b (deref_d32_set_b b v))"
  apply (simp only: ValRelSimp)
  apply (case_tac x; simp)
  apply (elim conjE disjE; simp, simp only: deref_d9_get_b_def deref_d32_set_b_def)
    apply (tactic \<open>getput_variant_tac @{context}\<close>)
  done

lemma get_a_set_b[GetSetSimp] : "deref_d3_get_a (deref_d32_set_b b v) = deref_d3_get_a b"
  apply (simp only: deref_d3_get_a_def deref_d32_set_b_def)
  apply ( tactic \<open>getput_variant_tac @{context}\<close>)
  done

lemma get_b_set_a[GetSetSimp] : "deref_d9_get_b (deref_d27_set_a b v) = deref_d9_get_b b"
  apply (simp only: deref_d9_get_b_def deref_d27_set_a_def)
  apply (tactic \<open>getput_variant_tac @{context}\<close>)
  done


(* 
These lemmas correspond to these kind of statements

3. `C_get = isabelle_get`
4. `C_set = isabelle_set
*)

lemma d3_get_a_def_alt[GetSetSimp] : "d3_get_a' x' = do _ <- guard (\<lambda>s. is_valid_t1_C s x');
                                         gets (\<lambda>s. deref_d3_get_a (heap_t1_C s x')) 
                                      od"
by (tactic \<open>custom_get_set_monadic_direct_tac @{context} 1\<close>)


lemma d9_get_b_def_alt[GetSetSimp] : "d9_get_b' x' = do _ <- guard (\<lambda>s. is_valid_t1_C s x');
                                         gets (\<lambda>s. deref_d9_get_b (heap_t1_C s x')) 
                                      od"
by (tactic \<open>custom_get_set_monadic_direct_tac @{context} 1\<close>)

lemma d27_set_a'_def_alt[GetSetSimp] :
"d27_set_a' ptr v = (do _ <- guard (\<lambda>s. is_valid_t1_C s ptr);
        modify (heap_t1_C_update (\<lambda>a. a(ptr := deref_d27_set_a (a ptr) v))) od )
"    
by (tactic \<open>custom_get_set_monadic_direct_tac @{context} 1\<close>)

lemma d32_set_b'_def_alt[GetSetSimp] :
"d32_set_b' ptr v = (do _ <- guard (\<lambda>s. is_valid_t1_C s ptr);
        modify (heap_t1_C_update (\<lambda>a. a(ptr := deref_d32_set_b (a ptr) v))) od )
"        
by (tactic \<open>custom_get_set_monadic_direct_tac @{context} 1\<close>)
end

(*

Once the get/set lemmas have been proven, the rest follows, as 
- the lemma statement generation has been adapted to record with custom layouts
- the specialised tactics have been adapted to take into account custom layouts,
using the lemma bucket GetSetSimp.

*)

(*

In summary, the remaining tasks are:
1. (easy) automate the generation of value/type relations for custom layouts
2. (easy) automate the generation of get/set lemma statements
3. (hard) automate the proof of get/set lemmas

*)


(* 
End of non-generated
*)

local_setup \<open> local_setup_val_rel_type_rel_put_them_in_buckets "variant_dargentisa.c" \<close>
local_setup \<open> local_setup_instantiate_cogent_C_heaps_store_them_in_buckets "variant_dargentisa.c" \<close>
locale Variant_dargentisa = "variant_dargentisa" + update_sem_init
begin

(* Relation between program heaps *)
definition
  heap_rel_ptr ::
  "(funtyp, abstyp, ptrtyp) store \<Rightarrow> lifted_globals \<Rightarrow>
   ('a :: cogent_C_heap) ptr \<Rightarrow> bool"
where
  "\<And> \<sigma> h p.
    heap_rel_ptr \<sigma> h p \<equiv>
   (\<forall> uv.
     \<sigma> (ptr_val p) = Some uv \<longrightarrow>
     type_rel (uval_repr uv) TYPE('a) \<longrightarrow>
     is_valid h p \<and> val_rel uv (heap h p))"

lemma heap_rel_ptr_meta:
  "heap_rel_ptr = heap_rel_meta is_valid heap"
  by (simp add: heap_rel_ptr_def[abs_def] heap_rel_meta_def[abs_def])

local_setup \<open> local_setup_heap_rel "variant_dargentisa.c" \<close>

definition state_rel :: "((funtyp, abstyp, ptrtyp) store \<times> lifted_globals) set"
where
  "state_rel  = {(\<sigma>, h). heap_rel \<sigma> h}"

lemmas val_rel_simps[ValRelSimp] =
  val_rel_word
  val_rel_ptr_def
  val_rel_unit_def
  val_rel_unit_t_C_def
  val_rel_bool_t_C_def
  val_rel_fun_tag

lemmas type_rel_simps[TypeRelSimp] =
  type_rel_word
  type_rel_ptr_def
  type_rel_unit_def
  type_rel_unit_t_C_def
  type_rel_bool_t_C_def

(* Generating the specialised take and put lemmas *)

local_setup \<open> local_setup_take_put_member_case_esac_specialised_lemmas "variant_dargentisa.c" \<close>
local_setup \<open> fold tidy_C_fun_def' Cogent_functions \<close>

end (* of locale *)


end
