(*
This file is generated by Cogent

*)

theory Variant_dargentisa_TypeProof
imports "Cogent.TypeProofGen"
"Cogent.AssocLookup"
begin

definition
  abbreviatedType1 :: " Cogent.type"
where
  "abbreviatedType1 \<equiv> TRecord [(''a'', (TSum [(''A'', (TPrim (Num U8), Unchecked))], Present)), (''b'', (TSum [(''A'', (TPrim (Num U8), Unchecked)), (''B'', (TPrim (Num U16), Unchecked)), (''C'', (TPrim (Num U32), Unchecked)), (''D'', (TPrim (Num U64), Unchecked)), (''E'', (TPrim Bool, Unchecked))], Present))] (Boxed Writable undefined)"

definition
  abbreviatedType2 :: " Cogent.type"
where
  "abbreviatedType2 \<equiv> TSum [(''A'', (TPrim (Num U8), Unchecked)), (''B'', (TPrim (Num U16), Unchecked)), (''C'', (TPrim (Num U32), Unchecked)), (''D'', (TPrim (Num U64), Unchecked)), (''E'', (TPrim Bool, Unchecked))]"

definition
  abbreviatedType3 :: " Cogent.type"
where
  "abbreviatedType3 \<equiv> TSum [(''A'', (TPrim (Num U8), Unchecked))]"

definition
  abbreviatedType4 :: " Cogent.type"
where
  "abbreviatedType4 \<equiv> TRecord [(''a'', (abbreviatedType3, Taken)), (''b'', (abbreviatedType2, Taken))] (Boxed Writable undefined)"

definition
  abbreviatedType5 :: " Cogent.type"
where
  "abbreviatedType5 \<equiv> TRecord [(''p1'', (abbreviatedType4, Present)), (''p2'', (TRecord [(''a'', (abbreviatedType3, Present)), (''b'', (abbreviatedType2, Present))] Unboxed, Present))] Unboxed"

definition
  abbreviatedType6 :: " Cogent.type"
where
  "abbreviatedType6 \<equiv> TRecord [(''a'', (abbreviatedType3, Present)), (''b'', (abbreviatedType2, Present))] Unboxed"

definition
  abbreviatedType7 :: " Cogent.type"
where
  "abbreviatedType7 \<equiv> TRecord [(''a'', (abbreviatedType3, Present)), (''b'', (abbreviatedType2, Present))] (Boxed Writable undefined)"

lemmas abbreviated_type_defs =
  abbreviatedType3_def
  abbreviatedType2_def
  abbreviatedType6_def
  abbreviatedType7_def
  abbreviatedType4_def
  abbreviatedType1_def
  abbreviatedType5_def

definition
  getVals_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "getVals_type \<equiv> ([], (abbreviatedType7, TRecord [(''p1'', (abbreviatedType4, Present)), (''p2'', (abbreviatedType6, Present))] Unboxed))"

definition
  getVals :: "string Cogent.expr"
where
  "getVals \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (LetBang (set [1]) (Struct [abbreviatedType3, abbreviatedType2] [Var 2, Var 0]) (Struct [abbreviatedType4, abbreviatedType6] [Var 2, Var 0])))"

definition
  putVals_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "putVals_type \<equiv> ([], (abbreviatedType4, abbreviatedType7))"

definition
  putVals :: "string Cogent.expr"
where
  "putVals \<equiv> Let (Var 0) (Let (Lit (LU8 18)) (Let (Con [(''A'', (TPrim (Num U8), Unchecked))] ''A'' (Var 0)) (Let (Put (Var 2) 0 (Var 0)) (Let (Lit (LU32 2022747085)) (Let (Con [(''A'', (TPrim (Num U8), Checked)), (''B'', (TPrim (Num U16), Checked)), (''C'', (TPrim (Num U32), Unchecked)), (''D'', (TPrim (Num U64), Checked)), (''E'', (TPrim Bool, Checked))] ''C'' (Var 0)) (Let (Promote abbreviatedType2 (Var 0)) (Put (Var 3) 1 (Var 0))))))))"

ML \<open>
val Cogent_functions = ["getVals", "putVals"]
val Cogent_abstract_functions = []
\<close>

definition
  \<Xi> :: " string \<Rightarrow>  Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "\<Xi> \<equiv> assoc_lookup [(''getVals'', getVals_type), (''putVals'', putVals_type)] ([], TUnit, TUnit)"

definition
  "\<xi> \<equiv> assoc_lookup []"

definition
  "getVals_typetree \<equiv> TyTrSplit (Cons (Some TSK_L) []) [] TyTrLeaf [Some abbreviatedType3, Some (TRecord [(''a'', (abbreviatedType3, Taken)), (''b'', (abbreviatedType2, Present))] (Boxed Writable undefined))] (TyTrSplit (Cons (Some TSK_R) (Cons (Some TSK_L) (Cons None []))) [] TyTrLeaf [Some abbreviatedType2, Some abbreviatedType4] (TyTrSplit (Cons (Some TSK_L) (Cons (Some TSK_NS) (Cons (Some TSK_L) (append (replicate 2 None) [])))) [] TyTrLeaf [Some abbreviatedType6] TyTrLeaf))"

definition
  "putVals_typetree \<equiv> TyTrSplit (Cons (Some TSK_L) []) [] TyTrLeaf [Some abbreviatedType4] (TyTrSplit (Cons (Some TSK_R) (Cons None [])) [] TyTrLeaf [Some (TPrim (Num U8))] (TyTrSplit (Cons (Some TSK_L) (Cons (Some TSK_R) (Cons None []))) [] TyTrLeaf [Some abbreviatedType3] (TyTrSplit (Cons (Some TSK_L) (Cons None (Cons (Some TSK_L) (Cons None [])))) [] TyTrLeaf [Some (TRecord [(''a'', (abbreviatedType3, Present)), (''b'', (abbreviatedType2, Taken))] (Boxed Writable undefined))] (TyTrSplit (Cons (Some TSK_R) (append (replicate 4 None) [])) [] TyTrLeaf [Some (TPrim (Num U32))] (TyTrSplit (Cons (Some TSK_L) (Cons (Some TSK_R) (append (replicate 4 None) []))) [] TyTrLeaf [Some (TSum [(''A'', (TPrim (Num U8), Checked)), (''B'', (TPrim (Num U16), Checked)), (''C'', (TPrim (Num U32), Unchecked)), (''D'', (TPrim (Num U64), Checked)), (''E'', (TPrim Bool, Checked))])] (TyTrSplit (Cons (Some TSK_L) (Cons None (Cons (Some TSK_R) (append (replicate 4 None) [])))) [] TyTrLeaf [Some abbreviatedType2] TyTrLeaf))))))"

ML \<open> open TTyping_Tactics \<close>

ML_quiet \<open>
val typing_helper_1_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_1[unfolded abbreviated_type_defs] :
  "kinding [] abbreviatedType7 {E}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_1_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_2_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_2[unfolded abbreviated_type_defs] :
  "kinding [] abbreviatedType3 {E, S, D}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_2_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_3_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_3[unfolded abbreviated_type_defs] :
  "kinding [] (TRecord [(''a'', (abbreviatedType3, Taken)), (''b'', (abbreviatedType2, Present))] (Boxed Writable undefined)) {E}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_3_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_4_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_4[unfolded abbreviated_type_defs] :
  "kinding [] abbreviatedType2 {E, S, D}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_4_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_5_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_5[unfolded abbreviated_type_defs] :
  "kinding [] abbreviatedType4 {E}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_5_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_6_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_6[unfolded abbreviated_type_defs] :
  "kinding [] (TRecord [(''a'', (abbreviatedType3, Taken)), (''b'', (abbreviatedType2, Taken))] (Boxed ReadOnly undefined)) {S, D}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_6_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_7_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_7[unfolded abbreviated_type_defs] :
  "kinding [] abbreviatedType6 {E, S, D}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_7_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_8_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_8[unfolded abbreviated_type_defs] :
  "kinding [] (TPrim (Num U8)) {E, S, D}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_8_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_9_script : tac list = [
(ForceTac [])
] \<close>


lemma typing_helper_9[unfolded abbreviated_type_defs] :
  "type_wellformed 0 abbreviatedType3"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_9_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_10_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_10[unfolded abbreviated_type_defs] :
  "kinding [] (TRecord [(''a'', (abbreviatedType3, Present)), (''b'', (abbreviatedType2, Taken))] (Boxed Writable undefined)) {E}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_10_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_11_script : tac list = [
(ForceTac [])
] \<close>


lemma typing_helper_11[unfolded abbreviated_type_defs] :
  "type_wellformed 0 abbreviatedType4"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_11_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_12_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_12[unfolded abbreviated_type_defs] :
  "kinding [] (TPrim (Num U32)) {E, S, D}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_12_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_13_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_13[unfolded abbreviated_type_defs] :
  "kinding [] (TSum [(''A'', (TPrim (Num U8), Checked)), (''B'', (TPrim (Num U16), Checked)), (''C'', (TPrim (Num U32), Unchecked)), (''D'', (TPrim (Num U64), Checked)), (''E'', (TPrim Bool, Checked))]) {E, S, D}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_13_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_14_script : tac list = [
(ForceTac [])
] \<close>


lemma typing_helper_14[unfolded abbreviated_type_defs] :
  "type_wellformed 0 (TSum [(''A'', (TPrim (Num U8), Checked)), (''B'', (TPrim (Num U16), Checked)), (''C'', (TPrim (Num U32), Unchecked)), (''D'', (TPrim (Num U64), Checked)), (''E'', (TPrim Bool, Checked))])"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_14_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_15_script : tac list = [
(ForceTac [])
] \<close>


lemma typing_helper_15[unfolded abbreviated_type_defs] :
  "type_wellformed 0 abbreviatedType2"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_15_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_16_script : tac list = [
(ForceTac [])
] \<close>


lemma typing_helper_16[unfolded abbreviated_type_defs] :
  "type_wellformed 0 (TRecord [(''a'', (abbreviatedType3, Present)), (''b'', (abbreviatedType2, Taken))] (Boxed Writable undefined))"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_16_script |> EVERY \<close>)
  done

ML_quiet \<open>
val getVals_typecorrect_script : hints treestep list = [
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_1})]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_2})]),
Val (KindingTacs [(RTac @{thm typing_helper_3})]),
StepUp,
Val (TypingTacs []),
Val (KindingTacs [(RTac @{thm typing_helper_2})]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_4})]),
Val (KindingTacs [(RTac @{thm typing_helper_5})]),
StepUp,
Val (TypingTacs []),
Val (KindingTacs [(RTac @{thm typing_helper_4})]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_6})]),
StepUp,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_7})]),
StepUp,
Val (TypingTacs []),
Val (TypingTacs []),
Val (KindingTacs [(RTac @{thm typing_helper_7})]),
StepUp,
StepUp,
StepUp,
StepUp
] \<close>


ML_quiet \<open>
val getVals_ttyping_details_future = get_all_typing_details_future false @{context} "getVals"
   getVals_typecorrect_script
\<close>


lemma getVals_typecorrect :
  "\<Xi>, prod.fst getVals_type, (getVals_typetree, [Some (prod.fst (prod.snd getVals_type))]) T\<turnstile> getVals : prod.snd (prod.snd getVals_type)"
  apply (tactic \<open> resolve_future_typecorrect @{context} getVals_ttyping_details_future \<close>)
  done

ML_quiet \<open>
val putVals_typecorrect_script : hints treestep list = [
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_5})]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_5})]),
StepUp,
Val (TypingTacs []),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_8})]),
StepUp,
Val (TypingTacs [(RTac @{thm typing_lit'}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac []),(SimpSolveTac ([],[]))]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_2})]),
StepUp,
Val (TypingTacs [(RTac @{thm typing_con}),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_8}]),(SimpSolveTac ([],[])),(SimpSolveTac ([],[])),(RTac @{thm type_wellformed_prettyI}),(SimpTac ([],@{thms type_wellformed.simps})),(RTac @{thm typing_helper_9}),(SimpSolveTac ([],[]))]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_10})]),
StepUp,
Val (TypingTacs [(RTac @{thm typing_put'}),(SplitsTac [SOME [(RTac @{thm split_comp.right}),(RTac @{thm type_wellformed_prettyI}),(SimpTac ([],@{thms type_wellformed.simps})),(RTac @{thm typing_helper_9})],NONE,SOME [(RTac @{thm split_comp.left}),(RTac @{thm type_wellformed_prettyI}),(SimpTac ([],@{thms type_wellformed.simps})),(RTac @{thm typing_helper_11})],NONE]),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_5}]),(SimpSolveTac ([],[])),(SimpSolveTac ([],[])),(SimpSolveTac ([],[])),(SimpSolveTac ([],[@{thm Product_Type.prod.inject}])),(RTac @{thm typing_helper_2}),(SimpSolveTac ([],[])),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_2}]),(SimpSolveTac ([],[])),(SimpSolveTac ([],[]))]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_12})]),
StepUp,
Val (TypingTacs [(RTac @{thm typing_lit'}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac []),(SimpSolveTac ([],[]))]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_13})]),
StepUp,
Val (TypingTacs [(RTac @{thm typing_con}),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_12}]),(SimpSolveTac ([],[])),(SimpSolveTac ([],[])),(RTac @{thm type_wellformed_prettyI}),(SimpTac ([],@{thms type_wellformed.simps})),(RTac @{thm typing_helper_14}),(SimpSolveTac ([],[]))]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_4})]),
StepUp,
Val (TypingTacs [(RTac @{thm typing_promote}),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_13}]),(SimpSolveTac ([],[])),(SubtypingTac [(RTac @{thm subty_tsum}),(RTac @{thm list_all2_cons}),(SimpTac ([],[])),(RTac @{thm subtyping_refl}),(RTac @{thm list_all2_cons}),(SimpTac ([],[])),(RTac @{thm subtyping_refl}),(RTac @{thm list_all2_cons}),(SimpTac ([],[])),(RTac @{thm subtyping_refl}),(RTac @{thm list_all2_cons}),(SimpTac ([],[])),(RTac @{thm subtyping_refl}),(RTac @{thm list_all2_cons}),(SimpTac ([],[])),(RTac @{thm subtyping_refl}),(RTac @{thm list_all2_nil}),(SimpSolveTac ([],[])),(ForceTac [])])]),
Val (TypingTacs [(RTac @{thm typing_put'}),(SplitsTac [SOME [(RTac @{thm split_comp.right}),(RTac @{thm type_wellformed_prettyI}),(SimpTac ([],@{thms type_wellformed.simps})),(RTac @{thm typing_helper_15})],NONE,SOME [(RTac @{thm split_comp.left}),(RTac @{thm type_wellformed_prettyI}),(SimpTac ([],@{thms type_wellformed.simps})),(RTac @{thm typing_helper_16})],NONE]),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_10}]),(SimpSolveTac ([],[])),(SimpSolveTac ([],[])),(SimpSolveTac ([],[])),(SimpSolveTac ([],[@{thm Product_Type.prod.inject}])),(RTac @{thm typing_helper_4}),(SimpSolveTac ([],[])),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_4}]),(SimpSolveTac ([],[])),(SimpSolveTac ([],[]))]),
StepUp,
StepUp,
StepUp,
StepUp,
StepUp,
StepUp,
StepUp,
StepUp
] \<close>


ML_quiet \<open>
val putVals_ttyping_details_future = get_all_typing_details_future false @{context} "putVals"
   putVals_typecorrect_script
\<close>


lemma putVals_typecorrect :
  "\<Xi>, prod.fst putVals_type, (putVals_typetree, [Some (prod.fst (prod.snd putVals_type))]) T\<turnstile> putVals : prod.snd (prod.snd putVals_type)"
  apply (tactic \<open> resolve_future_typecorrect @{context} putVals_ttyping_details_future \<close>)
  done

ML_quiet \<open>
val (_, getVals_typing_tree, getVals_typing_bucket)
= Future.join getVals_ttyping_details_future
\<close>


ML_quiet \<open>
val (_, putVals_typing_tree, putVals_typing_bucket)
= Future.join putVals_ttyping_details_future
\<close>


end
