(*
This file is generated by Cogent

*)

theory Nested_boxed_dargentisa_CorresSetup_Edited
imports "CogentCRefinement.Deep_Embedding_Auto"
"CogentCRefinement.Cogent_Corres"
"CogentCRefinement.Tidy"
"CogentCRefinement.Heap_Relation_Generation"
"CogentCRefinement.Type_Relation_Generation"
"CogentCRefinement.Dargent_Custom_Get_Set"
"build_nested_boxed/Nested_boxed_dargentisa_ACInstall"
"build_nested_boxed/Nested_boxed_dargentisa_TypeProof"
"../Complements"
begin

(* C type and value relations *)

instantiation unit_t_C :: cogent_C_val
begin
  definition type_rel_unit_t_C_def: "\<And> r. type_rel r (_ :: unit_t_C itself) \<equiv> r = RUnit"
  definition val_rel_unit_t_C_def: "\<And> uv. val_rel uv (_ :: unit_t_C) \<equiv> uv = UUnit"
  instance ..
end

instantiation bool_t_C :: cogent_C_val
begin
definition type_rel_bool_t_C_def: "\<And> typ. type_rel typ (_ :: bool_t_C itself) \<equiv> (typ = RPrim Bool)"
definition val_rel_bool_t_C_def:
   "\<And> uv x. val_rel uv (x :: bool_t_C) \<equiv> (boolean_C x = 0 \<or> boolean_C x = 1) \<and>
     uv = UPrim (LBool (boolean_C x \<noteq> 0))"
instance ..
end
context update_sem_init begin
lemmas corres_if = corres_if_base[where bool_val' = boolean_C,
                     OF _ _ val_rel_bool_t_C_def[THEN meta_eq_to_obj_eq, THEN iffD1]]
end
(* C heap type class *)
class cogent_C_heap = cogent_C_val +
  fixes is_valid    :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> bool"
  fixes heap        :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> 'a"

(*
Non-generated
*)



(* TODO: move this lemma in the C-parser library, where t1_C_updupd_same
is generated (c-parser/recursive_records/recursive_record_package.ML),
or pass them as an argument to generate_isa_getset
*)

(*
lemma heap_t1_C_update_comp[simp]:
  " heap_t1_C_update f o heap_t1_C_update f' = heap_t1_C_update (f o f')"
  by fastforce

lemma heap_t1_C_update_if[simp] : "
(if b then heap_t1_C_update f z else heap_t1_C_update g z) = 
  heap_t1_C_update (\<lambda> x. if b then f x else g x) z"
  by fastforce

lemma heap_t2_C_update_comp[simp]:
  " heap_t2_C_update f o heap_t2_C_update f' = heap_t2_C_update (f o f')"
  by fastforce

lemma heap_t2_C_update_if[simp] : "(if b then heap_t2_C_update f z else heap_t2_C_update g z) = 
  heap_t2_C_update (\<lambda> x. if b then f x else g x) z"
  by simp
*)



(* 
This ML function generate custom getters/setters in Isabelle from
the C custom getters/setters.

More precisely, the involved steps are:
1. get the names of custom C getters/setters from the table file
2. prove a simplified definition of them by unfolding the auxiliary 
   called C functions and using Tidy lemmas (thus produces Cgetter_def' 
   lemmas in the context). 
3. infer an isabelle definition of custom getter/setters by inspecting
   these simplified definition (and performing further simplification, such
   as removing all guards)

The simplified definitions are thought to be used later when proving that
the C and isabelle custom getters/setters match.

 *)


find_theorems name:get_aa
setup \<open>generate_isa_getset_records_for_file "nested_boxed_dargentisa.c" @{locale nested_boxed_dargentisa} \<close>

context nested_boxed_dargentisa begin


(* Example: 
 1 original C getter definition, 
 2 simplified unfolded definition
 3 isabelle C getter definition
*)
thm d3_get_aa'_def d3_get_aa'_def' deref_d3_get_aa_def
term deref_d3_get_aa

end
(* the value/type relation were adapted to custom layouts *)

thm val_rel_t2_C_def
thm type_rel_ptr_def
term Ptr
thm ptr_val_def

context nested_boxed_dargentisa begin
end
(* end of non-generated *)

local_setup \<open> local_setup_val_rel_type_rel_put_them_in_buckets "nested_boxed_dargentisa.c" \<close>
local_setup \<open> local_setup_instantiate_cogent_C_heaps_store_them_in_buckets "nested_boxed_dargentisa.c" \<close>
locale Nested_boxed_dargentisa = "nested_boxed_dargentisa" + update_sem_init
begin

(*



 *)

(* This prints the get/set lemmas that should be proven *)
ML \<open> val lems = mk_getset_lems "nested_boxed_dargentisa.c" @{context} \<close>
ML \<open>lems  |> map (string_of_getset_lem @{context})|> map tracing\<close>





thm L2opt
lemma d3_get_aa_def_alt[GetSetSimp] : "d3_get_aa' ptr = do _ <- guard (\<lambda>s. is_valid_t2_C s ptr);
                                                           gets (\<lambda>s. deref_d3_get_aa (heap_t2_C s ptr))
                                                        od"
  by (tactic \<open>custom_get_set_monadic_direct_tac @{context} 1\<close>)

lemma t2_C_get_aa_set_aa[GetSetSimp] : "val_rel x v \<Longrightarrow> val_rel x (deref_d3_get_aa (deref_d9_set_aa b v))"

  apply(simp add:deref_d3_get_aa_def deref_d9_set_aa_def)
  apply(rule_tac P="val_rel x"  in back_subst )
   apply assumption
  
  apply (cases v)
  apply clarsimp
  apply (thin_tac _)+  
  apply word_bitwise
  done

lemma t2_C_get_aa_set_aa'[GetSetSimp] : "val_rel x v \<longrightarrow> val_rel x (deref_d3_get_aa (deref_d9_set_aa b v))"
  apply (intro impI)
  apply (rule t2_C_get_aa_set_aa)
  by blast


lemma d9_set_aa_def_alt[GetSetSimp] : "d9_set_aa' ptr v =
                                       do _ <- guard (\<lambda>s. is_valid_t2_C s ptr);
                                          modify (heap_t2_C_update (\<lambda>a. a(ptr := deref_d9_set_aa (a ptr) v)))
                                       od"
by (tactic \<open>custom_get_set_monadic_direct_tac @{context} 1\<close>)


(* Relation between program heaps *)
definition
  heap_rel_ptr ::
  "(funtyp, abstyp, ptrtyp) store \<Rightarrow> lifted_globals \<Rightarrow>
   ('a :: cogent_C_heap) ptr \<Rightarrow> bool"
where
  "\<And> \<sigma> h p.
    heap_rel_ptr \<sigma> h p \<equiv>
   (\<forall> uv.
     \<sigma> (ptr_val p) = Some uv \<longrightarrow>
     type_rel (uval_repr uv) TYPE('a) \<longrightarrow>
     is_valid h p \<and> val_rel uv (heap h p))"

lemma heap_rel_ptr_meta:
  "heap_rel_ptr = heap_rel_meta is_valid heap"
  by (simp add: heap_rel_ptr_def[abs_def] heap_rel_meta_def[abs_def])

local_setup \<open> local_setup_heap_rel "nested_boxed_dargentisa.c" \<close>

definition state_rel :: "((funtyp, abstyp, ptrtyp) store \<times> lifted_globals) set"
where
  "state_rel  = {(\<sigma>, h). heap_rel \<sigma> h}"

lemmas val_rel_simps[ValRelSimp] =
  val_rel_word
  val_rel_ptr_def
  val_rel_unit_def
  val_rel_unit_t_C_def
  val_rel_bool_t_C_def
  val_rel_fun_tag

lemmas type_rel_simps[TypeRelSimp] =
  type_rel_word
  type_rel_ptr_def
  type_rel_unit_def
  type_rel_unit_t_C_def
  type_rel_bool_t_C_def
lemma idiot : "(val_rel x v \<longrightarrow> val_rel x v')
\<Longrightarrow> (val_rel x v \<Longrightarrow> val_rel x v')"
  by blast
(* non generated *)
lemma corres_put_t2_C_aa_writable : "[] \<turnstile> \<Gamma>' \<leadsto> \<Gamma>x | \<Gamma>e \<Longrightarrow>
\<Gamma>' ! x = Some (TRecord typ (Boxed Writable ptrl)) \<Longrightarrow>
type_rel (type_repr (TRecord typ (Boxed Writable ptrl))) TYPE(t2_C ptr) \<Longrightarrow>
val_rel (\<gamma> ! x) x' \<Longrightarrow>
val_rel (\<gamma> ! v) v' \<Longrightarrow>
\<Xi>', [], \<Gamma>' \<turnstile> Put (Var x) 0
               (Var v) : TRecord (typ[0 := (fst (typ ! 0), fst (snd (typ ! 0)), Present)]) (Boxed Writable ptrl) \<Longrightarrow>
length typ = 1 \<Longrightarrow> corres state_rel (Put (Var x) 0 (Var v)) (do ptr <- gets (\<lambda>_. x');
  _ <- d9_set_aa' ptr v';
  _ <- gets (\<lambda>_. ());
  gets (\<lambda>_. ptr)
                                                             od)
                    \<xi>' \<gamma> \<Xi>' \<Gamma>' \<sigma> s "
apply(tactic \<open>corres_put_boxed_tac @{context} 1\<close>)
  ML_prf \<open>
val ctxt = @{context}
  val gets = Proof_Context.get_thms ctxt
    val get  = Proof_Context.get_thm ctxt
    val type_rels  = TypeRelSimp.get ctxt;
    val val_rels   = ValRelSimp.get ctxt;
    val is_valids  = IsValidSimp.get ctxt;
    val heap_simps = HeapSimp.get ctxt;
    val getset_simps = GetSetSimp.get ctxt;
    val facts1 = get "val_rel_ptr_def" :: @{thms gets_to_return return_bind}
    val facts2 = maps gets
        ["state_rel_def", "heap_rel_def", "val_rel_ptr_def", "type_rel_ptr_def", "heap_rel_ptr_meta"]
    val facts3 = facts2 @ is_valids @ heap_simps
    fun trace str i t = (@{print tracing} str; @{print tracing} t; Seq.succeed t)
\<close>
  ML_prf \<open>
val tac1 =  (* use the nice definition of the getter/setter (if custom layout) *)
   simp_tac (ctxt addsimps (@{thm bind_assoc } ::getset_simps)) THEN'
    (EVERY' [
    asm_full_simp_tac ((put_simpset HOL_basic_ss ctxt) addsimps facts1),
    REPEAT_ALL_NEW (etac @{thm exE}),
    ((rtac (get "corres_put_boxed" |> Simplifier.rewrite_rule ctxt @{thms gets_to_return[THEN eq_reflection]})
        THEN' simp_tac ctxt
        THEN' atac THEN' atac THEN' atac)
        THEN_ALL_NEW asm_full_simp_tac ctxt),
    clarsimp_tac (ctxt addsimps facts3),
    (rtac (get "u_t_p_recE") THEN' atac) THEN_ALL_NEW asm_full_simp_tac ctxt,
    clarsimp_tac (ctxt addSDs (gets "type_repr_uval_repr")
        addsimps type_rels),
    (ftac (get "all_heap_rel_ptrD") THEN' atac)
        THEN_ALL_NEW asm_full_simp_tac (ctxt addsimps type_rels),
    (* The following two lines are not in the ORELSE' branch
       (that is the only difference between the two branches, with the nested ORELSE' branch)
       TODO factorize
     *)
    clarsimp_tac ctxt
(*,
    REPEAT_ALL_NEW (rtac @{thm conjI})
        THEN_ALL_NEW ((rtac (get "all_heap_rel_updE") THEN' atac THEN' atac)
            THEN_ALL_NEW distinct_subgoal_tac
            THEN_ALL_NEW asm_full_simp_tac (ctxt addsimps getset_simps) 
            THEN_ALL_NEW asm_simp_tac (ctxt addsimps val_rels @ type_rels)
            THEN_ALL_NEW asm_simp_tac (ctxt addsimps @{thms map_update list_update_eq_id}
                delsimps @{thms length_0_conv length_greater_0_conv})
            THEN_ALL_NEW clarsimp_tac (ctxt addsimps val_rels @ type_rels)
        )*)
    ]  ) 
\<close>

  apply (tactic \<open>tac1 1\<close>)
  apply (tactic \<open>  (REPEAT_ALL_NEW (rtac @{thm conjI}) 
THEN_ALL_NEW ((rtac (get "all_heap_rel_updE") THEN' atac THEN' atac)
  THEN_ALL_NEW distinct_subgoal_tac
            THEN_ALL_NEW asm_full_simp_tac (ctxt addsimps getset_simps) 
(* ok *)
(*  THEN_ALL_NEW asm_simp_tac (ctxt addsimps val_rels @ type_rels) *)
      
))
1
\<close>)
  thm corres_def
  term type_rel
  thm state_rel_def[simplified heap_rel_def, simplified] heap_rel_ptr_def
(* end of non generated *)

(* Generating the specialised take and put lemmas *)

local_setup \<open> local_setup_take_put_member_case_esac_specialised_lemmas "nested_boxed_dargentisa.c" \<close>
local_setup \<open> fold tidy_C_fun_def' Cogent_functions \<close>

end (* of locale *)


end
