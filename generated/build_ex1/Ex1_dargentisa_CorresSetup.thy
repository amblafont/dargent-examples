(*
This file is generated by Cogent

*)

theory Ex1_dargentisa_CorresSetup
imports "CogentCRefinement.Deep_Embedding_Auto"
"CogentCRefinement.Cogent_Corres"
"CogentCRefinement.Tidy"
"CogentCRefinement.Heap_Relation_Generation"
"CogentCRefinement.Type_Relation_Generation"
"CogentCRefinement.Dargent_Custom_Get_Set"
"Ex1_dargentisa_ACInstall"
"Ex1_dargentisa_TypeProof"
"../../Complements"
begin



(* C type and value relations *)

instantiation unit_t_C :: cogent_C_val
begin
  definition type_rel_unit_t_C_def: "\<And> r. type_rel r (_ :: unit_t_C itself) \<equiv> r = RUnit"
  definition val_rel_unit_t_C_def: "\<And> uv. val_rel uv (_ :: unit_t_C) \<equiv> uv = UUnit"
  instance ..
end

instantiation bool_t_C :: cogent_C_val
begin
definition type_rel_bool_t_C_def: "\<And> typ. type_rel typ (_ :: bool_t_C itself) \<equiv> (typ = RPrim Bool)"
definition val_rel_bool_t_C_def:
   "\<And> uv x. val_rel uv (x :: bool_t_C) \<equiv> (boolean_C x = 0 \<or> boolean_C x = 1) \<and>
     uv = UPrim (LBool (boolean_C x \<noteq> 0))"
instance ..
end
context update_sem_init begin
lemmas corres_if = corres_if_base[where bool_val' = boolean_C,
                     OF _ _ val_rel_bool_t_C_def[THEN meta_eq_to_obj_eq, THEN iffD1]]
end
(* C heap type class *)
class cogent_C_heap = cogent_C_val +
  fixes is_valid    :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> bool"
  fixes heap        :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> 'a"
(* generate direct definitions of custom getter/setters (for custom layouts) by
   inspecting their monadic definitions *)
setup \<open> generate_isa_getset_records_for_file "ex1_dargentisa.c" @{locale ex1_dargentisa} \<close>
local_setup \<open> local_setup_val_rel_type_rel_put_them_in_buckets "ex1_dargentisa.c" \<close>
local_setup \<open> local_setup_instantiate_cogent_C_heaps_store_them_in_buckets "ex1_dargentisa.c" \<close>
locale Ex1_dargentisa = "ex1_dargentisa" + update_sem_init
begin


(* The get/set lemmas that must be proven *)
ML \<open>val lems = mk_getset_lems "ex1_dargentisa.c" @{context} \<close>
ML \<open>lems  |> map (string_of_getset_lem @{context})|> map tracing\<close>

(* Non-generated by the compiler *)

lemma tags_distinct':
  "TAG_ENUM_Con0 \<noteq> TAG_ENUM_Con1"
  by (simp add: TAG_ENUM_Con0_def TAG_ENUM_Con1_def)
  

lemmas tags_distinct = tags_distinct' tags_distinct'[symmetric]




lemma t9_C_get_field0_set_field0[GetSetSimp] : "val_rel x v \<Longrightarrow>
          val_rel x (deref_d10_get_field0 (deref_d54_set_field0 b v))"
  apply(simp only:ValRelSimp)
  apply(case_tac x; simp)
  apply (elim conjE disjE; simp, simp only: GetSetDefs)
  apply (tactic \<open>getput_variant_tac @{context} @{thms tags_distinct}\<close>)
  sorry

lemma t9_C_get_field2_set_field2' : "val_rel x v \<Longrightarrow>
   val_rel x (deref_d52_get_field2 (deref_d96_set_field2 b v))"
  sorry

lemma t9_C_get_field2_set_field2[GetSetSimp] : "val_rel x v \<Longrightarrow>
   val_rel x (deref_d52_get_field2 (deref_d96_set_field2 b v))"
  sorry

lemma t9_C_get_field1_set_field1[GetSetSimp] : "val_rel x v \<Longrightarrow>
   val_rel x (deref_d17_get_field1 (deref_d61_set_field1 b v))"
  sorry 

lemma t9_C_get_field2_set_field0[GetSetSimp] : "deref_d52_get_field2
    (deref_d54_set_field0 b v) =
   deref_d52_get_field2 b"
  apply (simp only: GetSetDefs)
  by (tactic \<open>getput_variant_tac @{context} @{thms tags_distinct}\<close>)
  
lemma t9_C_get_field2_set_field1[GetSetSimp] : "deref_d52_get_field2
    (deref_d61_set_field1 b v) =
   deref_d52_get_field2 b"
   apply (simp only: GetSetDefs)
  by (tactic \<open>getput_variant_tac @{context} @{thms tags_distinct}\<close>)



lemma t9_C_get_field1_set_field0[GetSetSimp] : "deref_d17_get_field1
    (deref_d54_set_field0 b v) =
   deref_d17_get_field1 b"
     apply (simp only: GetSetDefs)
  by (tactic \<open>getput_variant_tac @{context} @{thms tags_distinct}\<close>)

lemma t9_C_get_field1_set_field2[GetSetSimp] : "deref_d17_get_field1
    (deref_d96_set_field2 b v) =
   deref_d17_get_field1 b"
     apply (simp only: GetSetDefs)
  by (tactic \<open>getput_variant_tac @{context} @{thms tags_distinct}\<close>)

lemma t9_C_get_field0_set_field1[GetSetSimp] : "deref_d10_get_field0
    (deref_d61_set_field1 b v) =
   deref_d10_get_field0 b"
    apply (simp only: GetSetDefs)
  by (tactic \<open>getput_variant_tac @{context} @{thms tags_distinct}\<close>)
lemma t9_C_get_field0_set_field2[GetSetSimp] : "deref_d10_get_field0
    (deref_d96_set_field2 b v) =
   deref_d10_get_field0 b"
     apply (simp only: GetSetDefs)
  by (tactic \<open>getput_variant_tac @{context} @{thms tags_distinct}\<close>)



lemma d10_get_field0_def_alt[GetSetSimp] : "d10_get_field0' ptr =
                                            do _ <- guard (\<lambda>s. is_valid_t9_C s ptr);
  gets (\<lambda>s. deref_d10_get_field0 (heap_t9_C s ptr))
                                            od"
   by(tactic \<open> custom_get_set_monadic_direct_tac @{context} 1\<close> )
lemma d54_set_field0_def_alt[GetSetSimp] : "d54_set_field0' ptr v =
                                            do _ <- guard (\<lambda>s. is_valid_t9_C s ptr);
  modify (heap_t9_C_update (\<lambda>a. a(ptr := deref_d54_set_field0 (a ptr) v)))
                                            od"
  by(tactic \<open> custom_get_set_monadic_direct_tac @{context} 1\<close> )

lemma d17_get_field1_def_alt[GetSetSimp] : "d17_get_field1' ptr =
                                            do _ <- guard (\<lambda>s. is_valid_t9_C s ptr);
  gets (\<lambda>s. deref_d17_get_field1 (heap_t9_C s ptr))
                                            od"
  by(tactic \<open> custom_get_set_monadic_direct_tac @{context} 1\<close> )
lemma d61_set_field1_def_alt[GetSetSimp] : "d61_set_field1' ptr v =
                                            do _ <- guard (\<lambda>s. is_valid_t9_C s ptr);
  modify (heap_t9_C_update (\<lambda>a. a(ptr := deref_d61_set_field1 (a ptr) v)))
                                            od"
   by(tactic \<open> custom_get_set_monadic_direct_tac @{context} 1\<close> )
lemma d52_get_field2_def_alt[GetSetSimp] : "d52_get_field2' ptr =
                                            do _ <- guard (\<lambda>s. is_valid_t9_C s ptr);
  gets (\<lambda>s. deref_d52_get_field2 (heap_t9_C s ptr))
                                            od"
   by(tactic \<open> custom_get_set_monadic_direct_tac @{context} 1\<close> )
lemma d96_set_field2_def_alt[GetSetSimp] : "d96_set_field2' ptr v =
                                            do _ <- guard (\<lambda>s. is_valid_t9_C s ptr);
  modify (heap_t9_C_update (\<lambda>a. a(ptr := deref_d96_set_field2 (a ptr) v)))
                                            od"
   by(tactic \<open> custom_get_set_monadic_direct_tac @{context} 1\<close> )
(* End of non-generated *)

(* This proves the get/set lemmas (currently by cheating!) *)
local_setup \<open>local_setup_getset_lemmas "ex1_dargentisa.c" \<close>


(* Relation between program heaps *)
definition
  heap_rel_ptr ::
  "(funtyp, abstyp, ptrtyp) store \<Rightarrow> lifted_globals \<Rightarrow>
   ('a :: cogent_C_heap) ptr \<Rightarrow> bool"
where
  "\<And> \<sigma> h p.
    heap_rel_ptr \<sigma> h p \<equiv>
   (\<forall> uv.
     \<sigma> (ptr_val p) = Some uv \<longrightarrow>
     type_rel (uval_repr uv) TYPE('a) \<longrightarrow>
     is_valid h p \<and> val_rel uv (heap h p))"

lemma heap_rel_ptr_meta:
  "heap_rel_ptr = heap_rel_meta is_valid heap"
  by (simp add: heap_rel_ptr_def[abs_def] heap_rel_meta_def[abs_def])

local_setup \<open> local_setup_heap_rel "ex1_dargentisa.c" \<close>

definition state_rel :: "((funtyp, abstyp, ptrtyp) store \<times> lifted_globals) set"
where
  "state_rel  = {(\<sigma>, h). heap_rel \<sigma> h}"

lemmas val_rel_simps[ValRelSimp] =
  val_rel_word
  val_rel_ptr_def
  val_rel_unit_def
  val_rel_unit_t_C_def
  val_rel_bool_t_C_def
  val_rel_fun_tag

lemmas type_rel_simps[TypeRelSimp] =
  type_rel_word
  type_rel_ptr_def
  type_rel_unit_def
  type_rel_unit_t_C_def
  type_rel_bool_t_C_def

(* Generating the specialised take and put lemmas *)

local_setup \<open> local_setup_take_put_member_case_esac_specialised_lemmas "ex1_dargentisa.c" \<close>
local_setup \<open> fold tidy_C_fun_def' Cogent_functions \<close>

end (* of locale *)


end
