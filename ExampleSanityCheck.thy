(*
This file is generated by Cogent

*)

theory ExampleSanityCheck
imports "CogentCRefinement.Deep_Embedding_Auto"
"CogentCRefinement.Cogent_Corres"
"CogentCRefinement.Tidy"
"CogentCRefinement.Heap_Relation_Generation"
"CogentCRefinement.Type_Relation_Generation"
"CogentCRefinement.Dargent_Custom_Get_Set"
"serialise/build_main/Main_dargentfull_ACInstall"
"serialise/build_main/Main_dargentfull_TypeProof"
begin

(* C type and value relations *)

instantiation unit_t_C :: cogent_C_val
begin
  definition type_rel_unit_t_C_def: "\<And> r. type_rel r (_ :: unit_t_C itself) \<equiv> r = RUnit"
  definition val_rel_unit_t_C_def: "\<And> uv. val_rel uv (_ :: unit_t_C) \<equiv> uv = UUnit"
  instance ..
end

instantiation bool_t_C :: cogent_C_val
begin
definition type_rel_bool_t_C_def: "\<And> typ. type_rel typ (_ :: bool_t_C itself) \<equiv> (typ = RPrim Bool)"
definition val_rel_bool_t_C_def:
   "\<And> uv x. val_rel uv (x :: bool_t_C) \<equiv> (boolean_C x = 0 \<or> boolean_C x = 1) \<and>
     uv = UPrim (LBool (boolean_C x \<noteq> 0))"
instance ..
end
context update_sem_init begin
lemmas corres_if = corres_if_base[where bool_val' = boolean_C,
                     OF _ _ val_rel_bool_t_C_def[THEN meta_eq_to_obj_eq, THEN iffD1]]
end

lemmas val_rel_simps[ValRelSimp] =
  val_rel_word
  val_rel_ptr_def
  val_rel_unit_def
  val_rel_unit_t_C_def
  val_rel_bool_t_C_def
  val_rel_fun_tag

lemmas type_rel_simps[TypeRelSimp] =
  type_rel_word
  type_rel_ptr_def
  type_rel_unit_def
  type_rel_unit_t_C_def
  type_rel_bool_t_C_def

(* C heap type class *)
class cogent_C_heap = cogent_C_val +
  fixes is_valid    :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> bool"
  fixes heap        :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> 'a"
(* generate direct definitions of custom getter/setters (for custom layouts) by
   inspecting their monadic definitions *)
setup \<open> generate_isa_getset_records_for_file "main_dargentfull.c" @{locale main_dargentfull} \<close>
local_setup \<open> local_setup_val_rel_type_rel_put_them_in_buckets "main_dargentfull.c" \<close>
local_setup \<open> local_setup_instantiate_cogent_C_heaps_store_them_in_buckets "main_dargentfull.c" \<close>
locale Main_dargentfull = "main_dargentfull" + update_sem_init
begin

term deref_d5_get_b
thm val_rel_t1_C_def
thm val_rel_t2_C_def
thm deref_d7_get_a_def
find_consts name:data_C

definition find_position :: "nat \<Rightarrow> nat \<Rightarrow> nat \<times> nat"
  where "find_position si offset  = (offset div si, offset mod si)"

lemma " find_position 32 1 = (0, 1)"
  by (simp add:find_position_def)
term index

fun raw_get_bit :: "(('a::len0) word)['n::finite] \<Rightarrow> nat \<Rightarrow> 'a word"
  where "raw_get_bit arr pos = 
                (let (byte, off) = find_position LENGTH('a) pos in
                 arr.[byte] && 2^off )"


fun get_bit :: "(('a::len0) word)['n::finite] \<Rightarrow> nat \<Rightarrow> bool"
  where "get_bit arr pos = 
                (let (byte, off) = find_position LENGTH('a) pos in
                 arr.[byte] && 2^off = 0)"

definition "lay_a1 = LayBitRange (8, 16)"
thm layout_taken_bit_list
thm refl[of "layout_taken_bit_list (lay_a1)", simplified lay_a1_def, simplified
     layout_taken_bit_list.simps bitrange_taken_bit_list.simps]
value "layout_taken_bit_list (lay_a1)"
lemma "(5 :: nat) = x"
apply (simp add:numeral.simps)
term deref_d7_get_a
find_consts ptr_layout
lemma "
  (\<forall> x\<in> set(layout_taken_bit_list lay_a1). 
  raw_get_bit (t1_C.data_C s) x = raw_get_bit (t1_C.data_C t) x) 
\<Longrightarrow> 
  deref_d3_get_a s = deref_d3_get_a t"
  apply(simp add:lay_a1_def find_position_def)
  apply(erule conjE)+
  apply(tactic \<open>custom_get_set_different_field_tac @{context} 1\<close>)
  done
term deref_d9_set_a
term data_C
lemma "layout_taken_bit_list (LayBitRange(32,0)) = x"
  apply(simp add:upt.simps)
  find_theorems upt
  value "[0..<32]"
  find_theorems less name:cases
  thm nat_less_cases'
  thm lessE
  value "32 :: nat"
lemma "
x < 32
 \<Longrightarrow>
 x\<notin> set(layout_taken_bit_list lay_a1)
\<Longrightarrow> 
raw_get_bit (t1_C.data_C (deref_d9_set_a s b)) x =
raw_get_bit (t1_C.data_C s) x "
  apply(simp only:numeral.simps)
 apply(simp add:lay_a1_def find_position_def)
 apply(elim less_zeroE  less_SucE) 
  apply(tactic \<open>custom_get_set_different_field_tac @{context} 1\<close>)+
  done

(* The get/set lemmas that must be proven *)
ML \<open>val lems = mk_getset_lems "main_dargentfull.c" @{context} \<close>
ML \<open>lems  |> map (string_of_getset_lem @{context})|> map tracing\<close>

(* This proves the get/set lemmas (currently by cheating!) *)
local_setup \<open>local_setup_getset_lemmas "main_dargentfull.c" \<close>

term data_C


(* Relation between program heaps *)
definition
  heap_rel_ptr ::
  "(funtyp, abstyp, ptrtyp) store \<Rightarrow> lifted_globals \<Rightarrow>
   ('a :: cogent_C_heap) ptr \<Rightarrow> bool"
where
  "\<And> \<sigma> h p.
    heap_rel_ptr \<sigma> h p \<equiv>
   (\<forall> uv.
     \<sigma> (ptr_val p) = Some uv \<longrightarrow>
     type_rel (uval_repr uv) TYPE('a) \<longrightarrow>
     is_valid h p \<and> val_rel uv (heap h p))"

lemma heap_rel_ptr_meta:
  "heap_rel_ptr = heap_rel_meta is_valid heap"
  by (simp add: heap_rel_ptr_def[abs_def] heap_rel_meta_def[abs_def])

local_setup \<open> local_setup_heap_rel "main_dargentfull.c" \<close>

definition state_rel :: "((funtyp, abstyp, ptrtyp) store \<times> lifted_globals) set"
where
  "state_rel  = {(\<sigma>, h). heap_rel \<sigma> h}"

(* Generating the specialised take and put lemmas *)

local_setup \<open> local_setup_take_put_member_case_esac_specialised_lemmas "main_dargentfull.c" \<close>
local_setup \<open> fold tidy_C_fun_def' Cogent_functions \<close>

end (* of locale *)


end
