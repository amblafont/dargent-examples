(*
This file is generated by Cogent

*)

theory Onefield_bits_dargentisa_TypeProof_Edited
imports "/home/laf027/cogent/branches/dargentisa/c-refinement/TypeProofGen"
"/home/laf027/cogent/branches/dargentisa/cogent/isa/AssocLookup"
begin

definition
  abbreviatedType1 :: " Cogent.type"
where
  "abbreviatedType1 \<equiv> TRecord [(''aa'', (TPrim (Num U32), Present))] (Boxed Writable undefined)"

lemmas abbreviated_type_defs =
  abbreviatedType1_def

definition
  main_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "main_type \<equiv> ([], (abbreviatedType1, abbreviatedType1))"

definition
  main :: "string Cogent.expr"
where
  "main \<equiv> Take (Var 0) 0 (Let (Prim (Plus U32) [Var 0, Lit (LU32 1)]) (Put (Var 2) 0 (Var 0)))"

ML \<open>
val Cogent_functions = ["main"]
val Cogent_abstract_functions = []
\<close>

definition
  \<Xi> :: " string \<Rightarrow>  Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "\<Xi> \<equiv> assoc_lookup [(''main'', main_type)] ([], TUnit, TUnit)"

definition
  "\<xi> \<equiv> assoc_lookup []"

definition
  "main_typetree \<equiv> TyTrSplit (Cons (Some TSK_L) []) [] TyTrLeaf [Some (TPrim (Num U32)), Some (TRecord [(''aa'', (TPrim (Num U32), Taken))] (Boxed Writable undefined))] (TyTrSplit (Cons (Some TSK_L) (Cons (Some TSK_R) (Cons None []))) [] TyTrLeaf [Some (TPrim (Num U32))] TyTrLeaf)"

ML \<open> open TTyping_Tactics \<close>

ML_quiet \<open>
val typing_helper_1_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_1[unfolded abbreviated_type_defs] :
  "kinding [] abbreviatedType1 {E}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_1_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_2_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_2[unfolded abbreviated_type_defs] :
  "kinding [] (TPrim (Num U32)) {E, S, D}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_2_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_3_script : tac list = [
(ForceTac [@{thm kinding_def},@{thm kinding_all_def},@{thm kinding_variant_def},@{thm kinding_record_def}])
] \<close>


lemma typing_helper_3[unfolded abbreviated_type_defs] :
  "kinding [] (TRecord [(''aa'', (TPrim (Num U32), Taken))] (Boxed Writable undefined)) {E}"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_3_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_4_script : tac list = [
(ForceTac [])
] \<close>


lemma typing_helper_4[unfolded abbreviated_type_defs] :
  "type_wellformed 0 (TPrim (Num U32))"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_4_script |> EVERY \<close>)
  done

ML_quiet \<open>
val typing_helper_5_script : tac list = [
(ForceTac [])
] \<close>


lemma typing_helper_5[unfolded abbreviated_type_defs] :
  "type_wellformed 0 (TRecord [(''aa'', (TPrim (Num U32), Taken))] (Boxed Writable undefined))"
  apply (unfold abbreviated_type_defs)?
  apply (tactic \<open> map (fn t => DETERM (interpret_tac t @{context} 1)) typing_helper_5_script |> EVERY \<close>)
  done

ML_quiet \<open>
val main_typecorrect_script : hints treestep list = [
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_1})]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_2})]),
Val (KindingTacs [(RTac @{thm typing_helper_3})]),
StepUp,
Val (TypingTacs []),
Val (KindingTacs [(RTac @{thm typing_helper_2})]),
StepDown,
StepDown,
Val (KindingTacs [(RTac @{thm typing_helper_2})]),
StepUp,
Val (TypingTacs [(RTac @{thm typing_prim'}),(SimpSolveTac ([],[])),(SimpSolveTac ([],[])),(RTac @{thm typing_all_cons}),(SplitsTac [SOME [(RTac @{thm split_comp.left}),(RTac @{thm type_wellformed_prettyI}),(SimpTac ([],@{thms type_wellformed.simps})),(RTac @{thm typing_helper_4})],NONE]),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_2}]),(SimpSolveTac ([],[])),(RTac @{thm typing_all_cons}),(SplitsTac [NONE]),(RTac @{thm typing_lit'}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac []),(SimpSolveTac ([],[])),(RTac @{thm typing_all_empty'[where n = "3"]}),(SimpTac ([@{thm empty_def}],[]))]),
Val (TypingTacs [(RTac @{thm typing_put'}),(SplitsTac [SOME [(RTac @{thm split_comp.right}),(RTac @{thm type_wellformed_prettyI}),(SimpTac ([],@{thms type_wellformed.simps})),(RTac @{thm typing_helper_4})],NONE,SOME [(RTac @{thm split_comp.left}),(RTac @{thm type_wellformed_prettyI}),(SimpTac ([],@{thms type_wellformed.simps})),(RTac @{thm typing_helper_5})],NONE]),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_3}]),(SimpSolveTac ([],[])),(SimpSolveTac ([],[])),(SimpSolveTac ([],[])),(SimpSolveTac ([],[@{thm Product_Type.prod.inject}])),(RTac @{thm typing_helper_2}),(SimpSolveTac ([],[])),(RTac @{thm typing_var}),(SimpTac ([@{thm empty_def}],[])),(WeakeningTac [@{thm typing_helper_2}]),(SimpSolveTac ([],[])),(SimpSolveTac ([],[]))]),
StepUp,
StepUp,
StepUp
] \<close>


ML_quiet \<open>
val main_ttyping_details_future = get_all_typing_details_future false @{context} "main"
   main_typecorrect_script
\<close>


lemma main_typecorrect :
  "\<Xi>, prod.fst main_type, (main_typetree, [Some (prod.fst (prod.snd main_type))]) T\<turnstile> main : prod.snd (prod.snd main_type)"
  apply (tactic \<open> resolve_future_typecorrect @{context} main_ttyping_details_future \<close>)
  done

ML_quiet \<open>
val (_, main_typing_tree, main_typing_bucket)
= Future.join main_ttyping_details_future
\<close>


end
