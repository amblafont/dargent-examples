(*
This file is generated by Cogent

*)

theory Onefield_bits_dargentisa_CorresSetup_Edited
imports "/home/laf027/cogent/branches/dargentisa/c-refinement/Deep_Embedding_Auto"
"/home/laf027/cogent/branches/dargentisa/c-refinement/Cogent_Corres"
"/home/laf027/cogent/branches/dargentisa/c-refinement/Tidy"
"/home/laf027/cogent/branches/dargentisa/c-refinement/Heap_Relation_Generation"
"/home/laf027/cogent/branches/dargentisa/c-refinement/Type_Relation_Generation"
"build_onefield_bits/Onefield_bits_dargentisa_ACInstall"
"build_onefield_bits/Onefield_bits_dargentisa_TypeProof"
"../Complements"
begin

(* C type and value relations *)

instantiation unit_t_C :: cogent_C_val
begin
  definition type_rel_unit_t_C_def: "\<And> r. type_rel r (_ :: unit_t_C itself) \<equiv> r = RUnit"
  definition val_rel_unit_t_C_def: "\<And> uv. val_rel uv (_ :: unit_t_C) \<equiv> uv = UUnit"
  instance ..
end

instantiation bool_t_C :: cogent_C_val
begin
definition type_rel_bool_t_C_def: "\<And> typ. type_rel typ (_ :: bool_t_C itself) \<equiv> (typ = RPrim Bool)"
definition val_rel_bool_t_C_def:
   "\<And> uv x. val_rel uv (x :: bool_t_C) \<equiv> (boolean_C x = 0 \<or> boolean_C x = 1) \<and>
     uv = UPrim (LBool (boolean_C x \<noteq> 0))"
instance ..
end



context update_sem_init begin
lemmas corres_if = corres_if_base[where bool_val' = boolean_C,
                     OF _ _ val_rel_bool_t_C_def[THEN meta_eq_to_obj_eq, THEN iffD1]]
end
(* C heap type class *)
class cogent_C_heap = cogent_C_val +
  fixes is_valid    :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> bool"
  fixes heap        :: "lifted_globals \<Rightarrow> 'a ptr \<Rightarrow> 'a"


(* Non generated stuff *)

(* TODO: move this lemma in the C-parser library, where t1_C_updupd_same
is generated (c-parser/recursive_records/recursive_record_package.ML)
*)
lemma heap_t1_C_update_comp[simp]:
  " heap_t1_C_update f o heap_t1_C_update f' = heap_t1_C_update (f o f')"
  by fastforce


ML 
\<open>
local
  val filename = "onefield_bits_dargentisa.c"
in
val uvals = read_table filename @{theory}
val g = get_callgraph @{theory} filename : callgraph
val heap_info = (Symtab.lookup (HeapInfo.get @{theory}) 
filename |> the  |> #heap_info)
end
\<close>

context onefield_bits_dargentisa begin

(* Unfold the definition of C getters and setters *)

local_setup \<open>generate_isa_getset_records g heap_info uvals  \<close>


lemma get_set_aa[GetSetSimp] : "deref_d2_get_aa (deref_d5_set_aa b v) = v"
  apply(simp add:deref_d2_get_aa_def deref_d5_set_aa_def)
  apply(cases v)
  apply simp
  by word_bitwise

(* Getter/Setter relate to their C counterparts *)


lemma d2_get_aa'_def_alt[GetSetSimp] : "d2_get_aa' x' = do _ <- guard (\<lambda>s. is_valid_t1_C s x');
                                         gets (\<lambda>s. deref_d2_get_aa (heap_t1_C s x')) 
                                      od"
  apply(simp add:d2_get_aa'_def' deref_d2_get_aa_def)  
  by monad_eq

lemma d5_set_aa'_def_alt[GetSetSimp] :
"d5_set_aa' ptr v = (do _ <- guard (\<lambda>s. is_valid_t1_C s ptr);
        modify (heap_t1_C_update (\<lambda>a. a(ptr := deref_d5_set_aa (a ptr) v))) od )
" 
  apply(simp add:deref_d5_set_aa_def d5_set_aa'_def')
  by (monad_eq simp add:comp_def)

end

(* no C counterpart (would be the counterpart of
an unboxed record nested in a record layout: then the 
compiler generate this) 
*)
abbreviation t1_C_aa_type 
   where  "t1_C_aa_type \<equiv> RPrim (Num U32)"

definition t1_C_to_uval :: "t1_C \<Rightarrow> (_,_,_) uval" 
 where t1_C_to_uval_def[GetSetSimp]  :
  "t1_C_to_uval b = URecord [(UPrim (LU32 (onefield_bits_dargentisa.deref_d2_get_aa b)), t1_C_aa_type )]"




(* Typeclass instances *)
instantiation t1_C :: cogent_C_val
begin
definition type_rel_t1_C_def[TypeRelSimp]: "\<And> typ. type_rel typ (_ :: t1_C itself) \<equiv> (typ = RRecord [t1_C_aa_type ])"
definition val_rel_t1_C_def[ValRelSimp]:
    " val_rel uv (x :: t1_C) \<equiv> uv = t1_C_to_uval x "
instance ..
end

(* main_prog should depend on x', e' and z *)
ML\<open> fun mk_specialised_corres_take_basic (field_num:int) uval main_prog custom_field_ty ctxt =
(* Generate specialised Take lemmas for the Writables and Unboxeds.*)
 let
  val _ = tracing "mk_specialised_corres_take"
  (* define auxiliary values and functions.*)
  val struct_C_nm     = get_ty_nm_C uval;
  val struct_ty       = Syntax.read_typ ctxt struct_C_nm;
  val struct_C_ptr_ty = Syntax.read_typ ctxt (struct_C_nm ^ " ptr");
    
  val isa_field_num   = encode_isa_int ctxt field_num;
  val get_clean_term  = fn str:string => Syntax.read_term ctxt str |> strip_atype;
  val state_rel       = get_clean_term "state_rel";
  
  val ml_sigil        = get_uval_sigil uval;
  val isa_sigil = case ml_sigil of
                ReadOnly => @{term "Boxed ReadOnly undefined"}
              | Writable => @{term "Boxed Writable undefined"}
              | Unboxed  => @{term "Unboxed"}
  (* Unboxed-Take and Boxed-Take use different types.*)
  val ty = case ml_sigil of
            Writable => struct_C_ptr_ty
          | Unboxed  => struct_ty
          | _        => error "ty in mk_specialised_corres_take failed.";

  (* define meta-assumptions in specialised corres lemmas.*)
  val ass1 = @{mk_term "\<Gamma>' ! x = Some (TRecord typ ?isa_sigil)" isa_sigil} isa_sigil;
  val ass2 = @{term    "[] \<turnstile> \<Gamma>' \<leadsto> \<Gamma>x | \<Gamma>e"};
  val ass3 = @{mk_term "val_rel (\<gamma>!x) ?x'" x'} (Free ("x'", ty));
  val ass4 = strip_atype @{term "\<lambda> isa_sigil ty . type_rel (type_repr (TRecord typ isa_sigil)) ty"}
            $ isa_sigil $ (Const ("Pure.type", Term.itselfT ty) |> strip_atype);
  val ass5 = strip_atype @{term "\<lambda> field_num ty . 
            type_rel (type_repr (fst (snd (typ ! field_num)))) ty"}
            $ isa_field_num $ (Const ("Pure.type", Term.itselfT custom_field_ty(* field_ty *)) |> strip_atype);
  val ass6 = strip_atype @{term "\<lambda> field_num . \<Xi>', [], \<Gamma>' \<turnstile> Take (Var x) field_num e : te"} $ isa_field_num;
  val ass7 = strip_atype @{term "\<lambda> isa_sigil . \<Xi>', [], \<Gamma>x \<turnstile> (Var x) : TRecord typ isa_sigil"} $ isa_sigil;
  val ass8 = strip_atype @{term "\<lambda> isa_sigil field_num .
             (\<Xi>', [], Some (fst (snd (typ ! field_num))) #
              Some (TRecord (typ[field_num := (fst (typ ! field_num), fst (snd (typ ! field_num)), taken)]) isa_sigil) # \<Gamma>e \<turnstile> e : te)"}
            $ isa_sigil $ isa_field_num;
  (* For some reason, I cannot use the mk-term antiquotation for ass9.*)
  val ass9 = strip_atype @{term "\<lambda> field_num . [] \<turnstile> fst (snd (typ ! field_num)) :\<kappa> k"} $ isa_field_num;
  val ass10= @{term "(S \<in> k \<or> taken = Taken)"};
  (* ass11 involves a bit ugly hacks. Maybe I can use \<lambda> for field_num instead of \<And>.*)
  val ass11 = let
               fun rep_Bound_n_with n new = strip_1qnt o
                   (Term.map_aterms (fn trm => if trm = Bound n then new else trm));
              in
              (strip_atype @{term "\<And> state_rel isa_sigil field_num vf z. val_rel vf z \<Longrightarrow>
               corres state_rel e (e' z) \<xi> (vf # (\<gamma>!x) # \<gamma>) \<Xi>'
                (Some (fst (snd (typ ! field_num))) # Some (TRecord (typ[field_num := (fst (typ ! field_num), fst (snd (typ ! field_num)), taken)])
                isa_sigil) # \<Gamma>e) \<sigma> s"})
               |> rep_Bound_n_with 4 state_rel
               |> rep_Bound_n_with 3 isa_sigil
               |> rep_Bound_n_with 2 isa_field_num
               |> up_ty_of_qnt "z" custom_field_ty ctxt
              end;
  val prms = map (HOLogic.mk_Trueprop o strip_atype)
   [ass1, ass2, ass3, ass4, ass5, ass6, ass7, ass8, ass9, ass10] @ [ass11];
  (* define the conclusion of the lemma.*)
  (* Unboxed-Take and Boxed-Take have different conclusions.*)
  val _ =
   case ml_sigil of
      ReadOnly => error "ReadOnly is not supported by cncl in mk_specialised_corres_take. :("
    | _ => ()
  val cncl =
     strip_atype @{term "\<lambda> state_rel field_num prog .
         corres state_rel
          (Take (Var x) field_num e)
          prog
           \<xi> \<gamma> \<Xi>' \<Gamma>' \<sigma> s"}
         $ state_rel $ isa_field_num $ main_prog
         |> HOLogic.mk_Trueprop
  val take_term = mk_meta_imps prms cncl ctxt |> Syntax.check_term ctxt;
  val _ = tracing ("    finished mk_spec_corres_take for struct " ^ (get_uval_name uval) ^ " " ^  Int.toString field_num);
 in take_term
 end;

 fun mk_specialised_corres_take_custom (field_num:int) uval 
   custom_getter custom_field_ty ctxt =
   mk_specialised_corres_take_basic field_num uval  
(@{term "\<lambda> getter.
(do v <- getter x' ;
                                        z <- gets (\<lambda>_. v) ;
                                          e' z
                                      od)
" } (* custom_getter *)
$ custom_getter) custom_field_ty ctxt

\<close>

ML \<open>
mk_specialised_corres_take_custom 0 monuval @{term onefield_bits_dargentisa.d2_get_aa'}  
 @{typ "32 word"}
@{context} |> Syntax.string_of_term @{context} |> tracing
\<close>

(* End of non generated stuff *)

local_setup \<open> local_setup_val_rel_type_rel_put_them_in_buckets "onefield_bits_dargentisa.c" \<close>
local_setup \<open> local_setup_instantiate_cogent_C_heaps_store_them_in_buckets "onefield_bits_dargentisa.c" \<close>
locale Onefield_bits_dargentisa = "onefield_bits_dargentisa" + update_sem_init
begin

(* Relation between program heaps *)
definition
  heap_rel_ptr ::
  "(funtyp, abstyp, ptrtyp) store \<Rightarrow> lifted_globals \<Rightarrow>
   ('a :: cogent_C_heap) ptr \<Rightarrow> bool"
where
  "\<And> \<sigma> h p.
    heap_rel_ptr \<sigma> h p \<equiv>
   (\<forall> uv.
     \<sigma> (ptr_val p) = Some uv \<longrightarrow>
     type_rel (uval_repr uv) TYPE('a) \<longrightarrow>
     is_valid h p \<and> val_rel uv (heap h p))"

lemma heap_rel_ptr_meta:
  "heap_rel_ptr = heap_rel_meta is_valid heap"
  by (simp add: heap_rel_ptr_def[abs_def] heap_rel_meta_def[abs_def])

local_setup \<open> local_setup_heap_rel "onefield_bits_dargentisa.c" \<close>

definition state_rel :: "((funtyp, abstyp, ptrtyp) store \<times> lifted_globals) set"
where
  "state_rel  = {(\<sigma>, h). heap_rel \<sigma> h}"

lemmas val_rel_simps[ValRelSimp] =
  val_rel_word
  val_rel_ptr_def
  val_rel_unit_def
  val_rel_unit_t_C_def
  val_rel_bool_t_C_def
  val_rel_fun_tag

lemmas type_rel_simps[TypeRelSimp] =
  type_rel_word
  type_rel_ptr_def
  type_rel_unit_def
  type_rel_unit_t_C_def
  type_rel_bool_t_C_def

(* Non generated stuff *)

(* Now, we need to generate the lemmas

Adapted from the following code, in the generated CorresSetup
file with typeclass instances for arrays
 *)

ML \<open>mk_lems "onefield_bits_dargentisa.c" @{context} |> 
  List.map (fn l => ( ( ("lemma " ^
(# name l) ^ "[" ^ bucket_to_string (# bucket l) ^ "] :\n\"" ^ ( (# prop l) |>
  (Syntax.string_of_term @{context}) ))
   |> writeln ); writeln "\"\n\n"))
 \<close>



(* Contrary to the generated lemma, v' is of type U32 rather than
array 
also, the original line was
 modify  (heap_t1_C_update (\<lambda>a. a(ptr := data_C_update (\<lambda>a. v') (a ptr))))

should be solved by
apply(tactic \<open>corres_put_boxed_tac @{context} 1\<close>
*)

lemmas facts1 = val_rel_ptr_def gets_to_return return_bind
lemmas facts2 = state_rel_def heap_rel_def val_rel_ptr_def type_rel_ptr_def heap_rel_ptr_meta
lemmas facts3 = facts2 IsValidSimp HeapSimp

(* below, the statements of the non prime lemmas was adapted from the original
generated lemmas and are proved automatically. Unfortunately, the prime lemmas
are the one that are used in corres_tac. I suggest writing a special tactic
for them which call the old ones for solving these goals. 
*) 

(* Not the right lemma (see writable' *)
lemma corres_put_t1_C_aa_writable :
"[] \<turnstile> \<Gamma>' \<leadsto> \<Gamma>x | \<Gamma>e \<Longrightarrow>
\<Gamma>' ! x = Some (TRecord typ (Boxed Writable ptrl)) \<Longrightarrow>
type_rel (type_repr (TRecord typ (Boxed Writable ptrl))) TYPE(t1_C ptr) \<Longrightarrow>
val_rel (\<gamma> ! x) x' \<Longrightarrow>
val_rel (\<gamma> ! v) (v' :: 32 word) \<Longrightarrow>
\<Xi>', [], \<Gamma>' \<turnstile> Put (Var x) 0
               (Var v) : TRecord
                          (typ[0 := (fst (typ ! 0), fst (snd (typ ! 0)),
                                     Present)])
                          (Boxed Writable ptrl) \<Longrightarrow> 

length typ = 1 \<Longrightarrow>
corres state_rel (Put (Var x) 0 (Var v))
 (do ptr <- gets (\<lambda>_. x');
     _ <- guard (\<lambda>s. is_valid_t1_C s ptr);
     _ <-
     modify (heap_t1_C_update (\<lambda>a. a(ptr := deref_d5_set_aa (a ptr) v' )))
      ;
     gets (\<lambda>_. ptr)
  od)
 \<xi>' \<gamma> \<Xi>' \<Gamma>' \<sigma> s "
  by  (tactic \<open>corres_put_boxed_tac @{context} 1\<close>)
(*
This is a decompilation of corres_put_boxed_tac

 apply (simp add:facts1)
  apply(elim exE)
  apply (cut_tac corres_put_boxed)
        apply (simp add:gets_to_return[THEN eq_reflection])
       apply(simp)
      apply(assumption)
     apply(assumption) 
    apply assumption
   apply assumption
  apply (clarsimp simp add:facts3)
  thm HeapSimp
  apply (erule u_t_p_recE)
   apply(clarsimp dest!:type_repr_uval_repr simp add:TypeRelSimp)
  apply(clarsimp dest!:type_repr_uval_repr simp add:TypeRelSimp)

  apply(frule all_heap_rel_ptrD)
    apply assumption  
   apply(clarsimp  simp add:TypeRelSimp)
  apply((frule all_heap_rel_updE, assumption) )  
  prefer 5
      apply (simp add:TypeRelSimp ValRelSimp)
     apply (simp add:TypeRelSimp ValRelSimp GetSetSimp )
    apply (simp add:TypeRelSimp ValRelSimp)
   apply (simp add:TypeRelSimp ValRelSimp )
  apply (simp add:TypeRelSimp ValRelSimp GetSetSimp)
*)
(* 
 type_rel (type_repr (fst (snd (typ ! 0)))) TYPE(32 word[2]) \<Longrightarrow>
*)
(* Not the right lemma *)
lemma corres_take_t1_C_aa_writable :
"\<Gamma>' ! x = Some (TRecord typ (Boxed Writable undefined)) \<Longrightarrow>
 [] \<turnstile> \<Gamma>' \<leadsto> \<Gamma>x | \<Gamma>e \<Longrightarrow>
 val_rel (\<gamma> ! x) x' \<Longrightarrow>
 type_rel (type_repr (TRecord typ (Boxed Writable undefined))) TYPE(t1_C ptr) \<Longrightarrow>
 type_rel (type_repr (fst (snd (typ ! 0)))) TYPE(32 word) \<Longrightarrow>
 \<Xi>', [], \<Gamma>' \<turnstile> Take (Var x) 0 e : te \<Longrightarrow>
 \<Xi>', [], \<Gamma>x \<turnstile> Var x : TRecord typ (Boxed Writable undefined) \<Longrightarrow>
 \<Xi>', [], Some (fst (snd (typ ! 0))) #
          Some (TRecord (typ[0 := (fst (typ ! 0), fst (snd (typ ! 0)), taken)]) (Boxed Writable undefined)) #
          \<Gamma>e \<turnstile> e : te \<Longrightarrow>
 [] \<turnstile> fst (snd (typ ! 0)) :\<kappa> k \<Longrightarrow>
 S \<in> k \<or> taken = Taken \<Longrightarrow>
 (\<And>vf z.
     val_rel vf z \<Longrightarrow>
     corres state_rel e (e' z) \<xi>' (vf # \<gamma> ! x # \<gamma>) \<Xi>'
      (Some (fst (snd (typ ! 0))) #
       Some (TRecord (typ[0 := (fst (typ ! 0), fst (snd (typ ! 0)), taken)]) (Boxed Writable undefined)) # \<Gamma>e)
      \<sigma> s) \<Longrightarrow>
 corres state_rel (Take (Var x) 0 e) (do _ <- guard (\<lambda>s. is_valid_t1_C s x');
                                         gets (\<lambda>s. deref_d2_get_aa (heap_t1_C s x')) >>= e'
                                      od)
  \<xi>' \<gamma> \<Xi>' \<Gamma>' \<sigma> s 
"
  by(tactic \<open>corres_take_boxed_tac @{context} 1\<close>)
(*
 apply(simp add:val_rel_ptr_def)
  apply (elim exE)
  apply (rule corres_take_boxed)
             apply simp
            apply simp
           apply simp
          apply simp
         apply (simp add:facts3)
        apply simp
       apply simp
      apply simp
     apply simp
    apply simp
   apply (simp add:facts3)

   apply (erule u_t_p_recE)
    apply(clarsimp dest!:type_repr_uval_repr simp add:TypeRelSimp)

   apply(clarsimp dest!:type_repr_uval_repr simp add:TypeRelSimp)
   apply(frule all_heap_rel_ptrD)
     apply assumption
    apply (clarsimp simp add:TypeRelSimp ValRelSimp)
   apply (clarsimp simp add:TypeRelSimp ValRelSimp GetSetSimp)
  apply (clarsimp simp add:TypeRelSimp ValRelSimp)
*)
  

lemma corres_member_t1_C_aa_writable[MemberReadOnly] :
"\<Gamma>' ! x = Some (TRecord typ (Boxed ReadOnly ptrl)) \<Longrightarrow>
 val_rel (\<gamma> ! x) x' \<Longrightarrow>
 type_rel (type_repr (TRecord typ (Boxed ReadOnly ptrl))) TYPE(t1_C ptr) \<Longrightarrow>
 type_rel (type_repr (fst (snd (typ ! 0)))) TYPE(32 word) \<Longrightarrow>
 \<Xi>', [], \<Gamma>' \<turnstile> Member (Var x) 0 : te \<Longrightarrow>
 \<Xi>', [], \<Gamma>' \<turnstile> Var x : TRecord typ (Boxed ReadOnly ptrl) \<Longrightarrow>
 corres state_rel (Member (Var x) 0) (do _ <- guard (\<lambda>s. is_valid_t1_C s x');
                                         gets (\<lambda>s. deref_d2_get_aa (heap_t1_C s x'))
                                      od)
  \<xi>' \<gamma> \<Xi>' \<Gamma>' \<sigma> s 
"
  by(tactic \<open>corres_take_boxed_tac @{context} 1\<close>)


lemma corres_let_put_t1_C_aa_writable[LetPutBoxed] :
"[] \<turnstile> \<Gamma>' \<leadsto> \<Gamma>x | \<Gamma>e \<Longrightarrow>
 \<Gamma>' ! x = Some (TRecord typ (Boxed Writable ptrl)) \<Longrightarrow>
 type_rel (type_repr (TRecord typ (Boxed Writable ptrl))) TYPE(t1_C ptr) \<Longrightarrow>
 val_rel (\<gamma> ! x) x' \<Longrightarrow>
 val_rel (\<gamma> ! v) v' \<Longrightarrow>
 \<Xi>', [], \<Gamma>' \<turnstile> expr.Let (Put (Var x) 0 (Var v)) e : ts \<Longrightarrow>
 \<Xi>', [], \<Gamma>x \<turnstile> Put (Var x) 0
                (Var v) : TRecord (typ[0 := (fst (typ ! 0), fst (snd (typ ! 0)), Present)])
                           (Boxed Writable ptrl) \<Longrightarrow>
 length typ = 1 \<Longrightarrow>
 (\<And>\<sigma> s. corres state_rel e (e' x') \<xi>' (\<gamma> ! x # \<gamma>) \<Xi>'
          (Some (TRecord (typ[0 := (fst (typ ! 0), fst (snd (typ ! 0)), Present)]) (Boxed Writable ptrl)) # \<Gamma>e) \<sigma>
          s) \<Longrightarrow>
 corres state_rel (expr.Let (Put (Var x) 0 (Var v)) e)
  (do ptr <- gets (\<lambda>_. x');
      _ <- guard (\<lambda>s. is_valid_t1_C s ptr);
      _ <- modify (heap_t1_C_update (\<lambda>a. a(ptr := deref_d5_set_aa (a ptr) v')));
      gets (\<lambda>_. ptr) >>= e'
   od)
  \<xi>' \<gamma> \<Xi>' \<Gamma>' \<sigma> s 
"
  by (tactic \<open>corres_let_put_boxed_tac @{context} 1\<close>)


(* Now we have all proven the lemmas that mk_lems should generate *)

(* But, in the proof of correspondence, it seems that we rather need the following 
   corres_take_t1_C_aa_writable' *)
(*  (do v <- d2_get_aa' a'; *)




  

(* This one is useful, not the previous *)
lemma corres_take_t1_C_aa_writable'[TakeBoxed] :
"\<Gamma>' ! x = Some (TRecord typ (Boxed Writable undefined)) \<Longrightarrow>
 [] \<turnstile> \<Gamma>' \<leadsto> \<Gamma>x | \<Gamma>e \<Longrightarrow>
 val_rel (\<gamma> ! x) x' \<Longrightarrow>
 type_rel (type_repr (TRecord typ (Boxed Writable undefined))) TYPE(t1_C ptr) \<Longrightarrow>
 type_rel (type_repr (fst (snd (typ ! 0)))) TYPE(32 word) \<Longrightarrow>
 \<Xi>', [], \<Gamma>' \<turnstile> Take (Var x) 0 e : te \<Longrightarrow>
 \<Xi>', [], \<Gamma>x \<turnstile> Var x : TRecord typ (Boxed Writable undefined) \<Longrightarrow>
 \<Xi>', [], Some (fst (snd (typ ! 0))) #
          Some (TRecord (typ[0 := (fst (typ ! 0), fst (snd (typ ! 0)), taken)]) (Boxed Writable undefined)) #
          \<Gamma>e \<turnstile> e : te \<Longrightarrow>
 [] \<turnstile> fst (snd (typ ! 0)) :\<kappa> k \<Longrightarrow>
 S \<in> k \<or> taken = Taken \<Longrightarrow>
 (\<And>vf z.
     val_rel vf z \<Longrightarrow>
     corres state_rel e (e' z) \<xi>' (vf # \<gamma> ! x # \<gamma>) \<Xi>'
      (Some (fst (snd (typ ! 0))) #
       Some (TRecord (typ[0 := (fst (typ ! 0), fst (snd (typ ! 0)), taken)]) (Boxed Writable undefined)) # \<Gamma>e)
      \<sigma> s) \<Longrightarrow>
 corres state_rel (Take (Var x) 0 e) (do v <- d2_get_aa' x' ;
                                         gets (\<lambda>_. v) >>=
                                          e' 
                                      od)
  \<xi>' \<gamma> \<Xi>' \<Gamma>' \<sigma> s 
"
(* 01/05 I found a solution by adding a redundant  z <- gets (\<lambda>_. v) ; 
This is because when the C code calls another function, AutoCorres always generate
such a useless gets. 
*)
 by(tactic \<open>corres_take_boxed_tac @{context} 1\<close>)
  



  

(* This lemma was guessed from the corres_tac missing part*)
lemma corres_put_t1_C_aa_writable'[PutBoxed] :
"[] \<turnstile> \<Gamma>' \<leadsto> \<Gamma>x | \<Gamma>e \<Longrightarrow>
\<Gamma>' ! x = Some (TRecord typ (Boxed Writable ptrl)) \<Longrightarrow>
type_rel (type_repr (TRecord typ (Boxed Writable ptrl))) TYPE(t1_C ptr) \<Longrightarrow>
val_rel (\<gamma> ! x) x' \<Longrightarrow>
val_rel (\<gamma> ! v) (v' :: 32 word) \<Longrightarrow>
\<Xi>', [], \<Gamma>' \<turnstile> Put (Var x) 0
               (Var v) : TRecord
                          (typ[0 := (fst (typ ! 0), fst (snd (typ ! 0)),
                                     Present)])
                          (Boxed Writable ptrl) \<Longrightarrow> 

length typ = 1 \<Longrightarrow>
corres state_rel (Put (Var x) 0 (Var v))
 (do ptr <- gets (\<lambda>_. x');
     _ <- d5_set_aa' ptr v'
      ;
     _ <- gets (\<lambda>_. ());
     gets (\<lambda>_. ptr)
  od)
 \<xi>' \<gamma> \<Xi>' \<Gamma>' \<sigma> s "
(*  apply( simp add:d5_set_aa'_def_alt bind_assoc) *)
by  (tactic \<open>corres_put_boxed_tac @{context} 1\<close>)
(*   apply (simp add:corres_put_t1_C_aa_writable[simplified]) 
  done *)
  


ML \<open>mk_urecord_lems_for_uval
 "onefield_bits_dargentisa.c" @{context}
(URecord ("t1", Writable, NONE) )
\<close>

print_ML_antiquotations
(* End of non generated stuff *)

(* Generating the specialised take and put lemmas *)

(* Non-generated stuff: supplementary argument: list of ignored types *)
local_setup \<open> local_setup_take_put_member_case_esac_specialised_lemmas_ignore_types "onefield_bits_dargentisa.c"
    ["t1_C"] 

 \<close>
local_setup \<open> fold tidy_C_fun_def' Cogent_functions \<close>

end (* of locale *)


end
